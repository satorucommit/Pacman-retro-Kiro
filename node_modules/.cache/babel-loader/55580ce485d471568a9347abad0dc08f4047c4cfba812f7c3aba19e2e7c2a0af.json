{"ast":null,"code":"import { Direction, CellType, GhostState, GhostType } from '../types/game.ts';\nimport { GAME_CONFIG, MAZE_LAYOUT, GHOST_CONFIG, PACMAN_START_POSITION } from '../config/gameConfig.ts';\nimport { AIEngine } from './AIEngine.ts';\n\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\nexport class GameEngine {\n  constructor() {\n    this.aiEngine = void 0;\n    this.gameState = void 0;\n    this.lastUpdateTime = 0;\n    this.frameCount = 0;\n    this.aiEngine = new AIEngine();\n    this.gameState = this.initializeGameState();\n  }\n\n  /**\r\n   * Initialize the game state with default values\r\n   */\n  initializeGameState() {\n    const maze = MAZE_LAYOUT.map(row => [...row]);\n    const pelletsRemaining = this.countPellets(maze);\n    return {\n      pacman: this.createPacMan(),\n      ghosts: this.createGhosts(),\n      maze,\n      score: 0,\n      highScore: parseInt(localStorage.getItem('pacman-highscore') || '0'),\n      lives: 3,\n      level: 1,\n      pelletsRemaining,\n      powerPelletActive: false,\n      powerPelletTimer: 0,\n      gameStatus: 'READY',\n      ghostEatenCount: 0,\n      fruitSpawned: false,\n      fruitPosition: null,\n      fruitScore: 0,\n      aiLearningLevel: 0,\n      showAIFeatures: true,\n      dangerMap: [],\n      playerPatterns: [],\n      screenShake: false,\n      vhsGlitch: false\n    };\n  }\n\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\n  createPacMan() {\n    return {\n      position: {\n        x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE,\n        y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE\n      },\n      velocity: {\n        dx: 0,\n        dy: 0\n      },\n      direction: Direction.NONE,\n      nextDirection: Direction.NONE,\n      animationFrame: 0,\n      isDead: false,\n      mouthOpen: true\n    };\n  }\n\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\n  createGhosts() {\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\n      id: type,\n      position: {\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE,\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE\n      },\n      velocity: {\n        dx: 0,\n        dy: 0\n      },\n      direction: Direction.UP,\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\n      color: config.color,\n      targetPosition: {\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE,\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE\n      },\n      scatterTarget: {\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE,\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE\n      },\n      houseTimer: type === 'BLINKY' ? 0 : 60 + Object.keys(GHOST_CONFIG).indexOf(type) * 30,\n      frightenedTimer: 0,\n      isFlashing: false,\n      lastDirection: Direction.UP,\n      pathPrediction: []\n    }));\n  }\n\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\n  update(currentTime, inputDirection) {\n    // const deltaTime = currentTime - this.lastUpdateTime;\n    this.lastUpdateTime = currentTime;\n    this.frameCount++;\n    if (this.gameState.gameStatus !== 'PLAYING') {\n      return this.gameState;\n    }\n\n    // Update Pac-Man\n    this.updatePacMan(inputDirection);\n\n    // Update ghosts\n    this.updateGhosts();\n\n    // Check collisions\n    this.checkCollisions();\n\n    // Update power pellet timer\n    this.updatePowerPelletTimer();\n\n    // Update AI analysis\n    this.updateAIAnalysis();\n\n    // Check win/lose conditions\n    this.checkGameConditions();\n\n    // Update visual effects\n    this.updateVisualEffects();\n\n    // Spawn fruit occasionally\n    this.updateFruitSpawning();\n    return this.gameState;\n  }\n\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\n  updatePacMan(inputDirection) {\n    const pacman = this.gameState.pacman;\n\n    // Handle direction changes\n    if (inputDirection !== Direction.NONE) {\n      pacman.nextDirection = inputDirection;\n\n      // Record movement for AI learning\n      this.aiEngine.recordPlayerMovement(inputDirection);\n    }\n\n    // Try to change direction if possible\n    if (pacman.nextDirection !== pacman.direction && pacman.nextDirection !== Direction.NONE) {\n      const gridX = Math.round(pacman.position.x / GAME_CONFIG.CELL_SIZE);\n      const gridY = Math.round(pacman.position.y / GAME_CONFIG.CELL_SIZE);\n      const nextGridPos = this.getNextPosition({\n        x: gridX,\n        y: gridY\n      }, pacman.nextDirection);\n      if (this.isValidMove(nextGridPos)) {\n        pacman.direction = pacman.nextDirection;\n        this.setVelocity(pacman, pacman.direction);\n      }\n    }\n\n    // Move Pac-Man\n    if (pacman.direction !== Direction.NONE) {\n      let nextX = pacman.position.x + pacman.velocity.dx;\n      let nextY = pacman.position.y + pacman.velocity.dy;\n\n      // Handle tunnel wraparound\n      if (nextX < 0) {\n        nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\n      } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\n        nextX = 0;\n      }\n\n      // Check if move is valid by converting to grid coordinates\n      const gridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\n      const gridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\n      if (this.isValidMove({\n        x: gridX,\n        y: gridY\n      })) {\n        pacman.position.x = nextX;\n        pacman.position.y = nextY;\n      } else {\n        // Stop if hitting wall\n        pacman.direction = Direction.NONE;\n        pacman.velocity = {\n          dx: 0,\n          dy: 0\n        };\n      }\n    }\n\n    // Update animation\n    if (this.frameCount % 8 === 0) {\n      pacman.mouthOpen = !pacman.mouthOpen;\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\n    }\n  }\n\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\n  updateGhosts() {\n    this.gameState.ghosts.forEach(ghost => {\n      this.updateGhostState(ghost);\n      this.updateGhostMovement(ghost);\n      this.updateGhostAnimation(ghost);\n    });\n  }\n\n  /**\r\n   * Update individual ghost state and target\r\n   */\n  updateGhostState(ghost) {\n    // Handle house timer\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\n      ghost.houseTimer--;\n      if (ghost.houseTimer <= 0) {\n        ghost.state = GhostState.CHASE;\n      }\n      return;\n    }\n\n    // Handle frightened state\n    if (ghost.state === GhostState.FRIGHTENED) {\n      ghost.frightenedTimer--;\n\n      // Start flashing when timer is low\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\n      }\n      if (ghost.frightenedTimer <= 0) {\n        ghost.state = GhostState.CHASE;\n        ghost.isFlashing = false;\n      }\n      return;\n    }\n\n    // Handle eaten state\n    if (ghost.state === GhostState.EATEN) {\n      // Return to house\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\n        ghost.state = GhostState.CHASE;\n      }\n      ghost.targetPosition = housePos;\n      return;\n    }\n\n    // Normal chase/scatter behavior with AI adaptation\n    // const baseTarget = this.getGhostTarget(ghost);\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(ghost, this.gameState.pacman, this.gameState.ghosts);\n\n    // Alternate between chase and scatter modes\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\n  }\n\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\n  updateGhostMovement(ghost) {\n    if (ghost.state === GhostState.IN_HOUSE) {\n      // Simple up-down movement in house\n      if (this.frameCount % 60 < 30) {\n        ghost.direction = Direction.UP;\n      } else {\n        ghost.direction = Direction.DOWN;\n      }\n      this.setGhostVelocity(ghost);\n      return;\n    }\n\n    // Get possible directions (can't reverse unless frightened)\n    const possibleDirections = this.getPossibleDirections(ghost.position).filter(dir => {\n      if (ghost.state === GhostState.FRIGHTENED) return true;\n      return this.getOppositeDirection(dir) !== ghost.lastDirection;\n    });\n    if (possibleDirections.length === 0) return;\n\n    // Choose direction based on target\n    let bestDirection = possibleDirections[0];\n    let shortestDistance = Infinity;\n    if (ghost.state === GhostState.FRIGHTENED) {\n      // Random movement when frightened\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n    } else {\n      // Move toward target\n      possibleDirections.forEach(direction => {\n        const nextPos = this.getNextPosition(ghost.position, direction);\n        const distance = this.manhattanDistance(nextPos, ghost.targetPosition);\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          bestDirection = direction;\n        }\n      });\n    }\n    ghost.lastDirection = ghost.direction;\n    ghost.direction = bestDirection;\n    this.setGhostVelocity(ghost);\n\n    // Move ghost\n    const nextPos = {\n      x: ghost.position.x + ghost.velocity.dx,\n      y: ghost.position.y + ghost.velocity.dy\n    };\n\n    // Handle tunnel wraparound\n    if (nextPos.x < 0) {\n      nextPos.x = GAME_CONFIG.MAZE_WIDTH - 1;\n    } else if (nextPos.x >= GAME_CONFIG.MAZE_WIDTH) {\n      nextPos.x = 0;\n    }\n    if (this.isValidMove(nextPos)) {\n      ghost.position = nextPos;\n    }\n  }\n\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\n  updateGhostAnimation(ghost) {\n    // Update path prediction for AI visualization\n    if (this.frameCount % 30 === 0) {\n      // Update every half second\n      const predictions = this.aiEngine.predictGhostMovements([ghost], this.gameState.maze, this.gameState.pacman);\n      ghost.pathPrediction = predictions[ghost.id] || [];\n    }\n  }\n\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\n  checkCollisions() {\n    const pacmanPos = this.gameState.pacman.position;\n    const cellType = this.gameState.maze[pacmanPos.y][pacmanPos.x];\n\n    // Collect pellets\n    if (cellType === CellType.PELLET) {\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\n      this.gameState.pelletsRemaining--;\n      this.playSound('CHOMP');\n    }\n\n    // Collect power pellets\n    if (cellType === CellType.POWER_PELLET) {\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\n      this.gameState.pelletsRemaining--;\n      this.activatePowerPellet();\n      this.playSound('POWER_PELLET');\n    }\n\n    // Collect fruit\n    if (this.gameState.fruitPosition && pacmanPos.x === this.gameState.fruitPosition.x && pacmanPos.y === this.gameState.fruitPosition.y) {\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\n      this.gameState.score += fruitPoints;\n      this.gameState.fruitScore = fruitPoints;\n      this.gameState.fruitPosition = null;\n      this.gameState.fruitSpawned = false;\n      this.playSound('FRUIT');\n    }\n\n    // Check ghost collisions\n    this.gameState.ghosts.forEach(ghost => {\n      if (this.manhattanDistance(pacmanPos, ghost.position) < 1) {\n        if (ghost.state === GhostState.FRIGHTENED) {\n          // Eat ghost\n          ghost.state = GhostState.EATEN;\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\n          this.gameState.score += points;\n          this.gameState.ghostEatenCount++;\n          this.gameState.screenShake = true;\n          this.playSound('GHOST_EATEN');\n        } else if (ghost.state !== GhostState.EATEN) {\n          // Pac-Man dies\n          this.gameState.pacman.isDead = true;\n          this.gameState.lives--;\n          this.gameState.screenShake = true;\n          this.playSound('DEATH');\n          if (this.gameState.lives <= 0) {\n            this.gameState.gameStatus = 'GAME_OVER';\n          } else {\n            // Reset positions\n            setTimeout(() => this.resetPositions(), 2000);\n          }\n        }\n      }\n    });\n  }\n\n  /**\r\n   * Activate power pellet effect\r\n   */\n  activatePowerPellet() {\n    this.gameState.powerPelletActive = true;\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\n    this.gameState.ghostEatenCount = 0;\n\n    // Make ghosts frightened\n    this.gameState.ghosts.forEach(ghost => {\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\n        ghost.state = GhostState.FRIGHTENED;\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\n        ghost.isFlashing = false;\n        // Reverse direction\n        ghost.direction = this.getOppositeDirection(ghost.direction);\n      }\n    });\n  }\n\n  /**\r\n   * Update power pellet timer\r\n   */\n  updatePowerPelletTimer() {\n    if (this.gameState.powerPelletActive) {\n      this.gameState.powerPelletTimer--;\n      if (this.gameState.powerPelletTimer <= 0) {\n        this.gameState.powerPelletActive = false;\n      }\n    }\n  }\n\n  /**\r\n   * Update AI analysis and danger map\r\n   */\n  updateAIAnalysis() {\n    if (this.frameCount % 10 === 0) {\n      // Update every 6th of a second\n      // const analysis = this.aiEngine.analyzeGameState(\n      //   this.gameState.pacman,\n      //   this.gameState.ghosts,\n      //   this.gameState.maze\n      // );\n\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(this.gameState.ghosts, this.gameState.maze);\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\n    }\n  }\n\n  /**\r\n   * Check win/lose conditions\r\n   */\n  checkGameConditions() {\n    // Check if all pellets collected\n    if (this.gameState.pelletsRemaining <= 0) {\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\n      this.gameState.level++;\n\n      // Reset maze and positions for next level\n      setTimeout(() => {\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\n        this.resetPositions();\n        this.gameState.gameStatus = 'READY';\n      }, 2000);\n    }\n\n    // Update high score\n    if (this.gameState.score > this.gameState.highScore) {\n      this.gameState.highScore = this.gameState.score;\n      localStorage.setItem('pacman-highscore', this.gameState.score.toString());\n    }\n  }\n\n  /**\r\n   * Update visual effects\r\n   */\n  updateVisualEffects() {\n    // Reset screen shake\n    if (this.gameState.screenShake) {\n      setTimeout(() => {\n        this.gameState.screenShake = false;\n      }, 200);\n    }\n\n    // Random VHS glitch effect\n    if (Math.random() < 0.001) {\n      this.gameState.vhsGlitch = true;\n      setTimeout(() => {\n        this.gameState.vhsGlitch = false;\n      }, 100);\n    }\n  }\n\n  /**\r\n   * Update fruit spawning logic\r\n   */\n  updateFruitSpawning() {\n    if (!this.gameState.fruitSpawned && this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\n      // Spawn fruit when 70% of pellets are eaten\n      this.gameState.fruitSpawned = true;\n      this.gameState.fruitPosition = {\n        x: 9,\n        y: 15\n      }; // Center of maze\n\n      // Remove fruit after 10 seconds\n      setTimeout(() => {\n        this.gameState.fruitPosition = null;\n        this.gameState.fruitSpawned = false;\n      }, 10000);\n    }\n  }\n\n  // Helper methods\n\n  getGhostTarget(ghost) {\n    const pacman = this.gameState.pacman;\n    switch (ghost.id) {\n      case GhostType.BLINKY:\n        return pacman.position;\n      case GhostType.PINKY:\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\n      case GhostType.INKY:\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\n        if (blinky) {\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\n          return {\n            x: ahead.x + (ahead.x - blinky.position.x),\n            y: ahead.y + (ahead.y - blinky.position.y)\n          };\n        }\n        return pacman.position;\n      case GhostType.CLYDE:\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\n      default:\n        return pacman.position;\n    }\n  }\n  getNextPosition(position, direction) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: position.y - 1\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: position.y + 1\n        };\n      case Direction.LEFT:\n        return {\n          x: position.x - 1,\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: position.x + 1,\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getPositionAhead(position, direction, distance) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: Math.max(0, position.y - distance)\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance)\n        };\n      case Direction.LEFT:\n        return {\n          x: Math.max(0, position.x - distance),\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance),\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getOppositeDirection(direction) {\n    switch (direction) {\n      case Direction.UP:\n        return Direction.DOWN;\n      case Direction.DOWN:\n        return Direction.UP;\n      case Direction.LEFT:\n        return Direction.RIGHT;\n      case Direction.RIGHT:\n        return Direction.LEFT;\n      default:\n        return Direction.NONE;\n    }\n  }\n  getPossibleDirections(position) {\n    const directions = [];\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\n      directions.push(Direction.UP);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\n      directions.push(Direction.DOWN);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\n      directions.push(Direction.LEFT);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\n      directions.push(Direction.RIGHT);\n    }\n    return directions;\n  }\n  isValidMove(position) {\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\n    const cellType = this.gameState.maze[position.y][position.x];\n    return cellType !== CellType.WALL;\n  }\n  setVelocity(entity, direction) {\n    const speed = GAME_CONFIG.PACMAN_SPEED;\n    switch (direction) {\n      case Direction.UP:\n        entity.velocity = {\n          dx: 0,\n          dy: -speed\n        };\n        break;\n      case Direction.DOWN:\n        entity.velocity = {\n          dx: 0,\n          dy: speed\n        };\n        break;\n      case Direction.LEFT:\n        entity.velocity = {\n          dx: -speed,\n          dy: 0\n        };\n        break;\n      case Direction.RIGHT:\n        entity.velocity = {\n          dx: speed,\n          dy: 0\n        };\n        break;\n      default:\n        entity.velocity = {\n          dx: 0,\n          dy: 0\n        };\n    }\n  }\n  setGhostVelocity(ghost) {\n    let speed = GAME_CONFIG.GHOST_SPEED;\n    if (ghost.state === GhostState.FRIGHTENED) {\n      speed = GAME_CONFIG.FRIGHTENED_SPEED;\n    } else if (ghost.state === GhostState.EATEN) {\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5; // Faster when returning to house\n    }\n    switch (ghost.direction) {\n      case Direction.UP:\n        ghost.velocity = {\n          dx: 0,\n          dy: -speed\n        };\n        break;\n      case Direction.DOWN:\n        ghost.velocity = {\n          dx: 0,\n          dy: speed\n        };\n        break;\n      case Direction.LEFT:\n        ghost.velocity = {\n          dx: -speed,\n          dy: 0\n        };\n        break;\n      case Direction.RIGHT:\n        ghost.velocity = {\n          dx: speed,\n          dy: 0\n        };\n        break;\n      default:\n        ghost.velocity = {\n          dx: 0,\n          dy: 0\n        };\n    }\n  }\n  manhattanDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n  }\n  countPellets(maze) {\n    let count = 0;\n    maze.forEach(row => {\n      row.forEach(cell => {\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\n          count++;\n        }\n      });\n    });\n    return count;\n  }\n  resetPositions() {\n    this.gameState.pacman.position = {\n      ...PACMAN_START_POSITION\n    };\n    this.gameState.pacman.direction = Direction.NONE;\n    this.gameState.pacman.velocity = {\n      dx: 0,\n      dy: 0\n    };\n    this.gameState.pacman.isDead = false;\n    this.gameState.ghosts.forEach(ghost => {\n      ghost.position = {\n        ...GHOST_CONFIG[ghost.id].startPosition\n      };\n      ghost.direction = Direction.UP;\n      ghost.velocity = {\n        dx: 0,\n        dy: 0\n      };\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\n    });\n    this.gameState.powerPelletActive = false;\n    this.gameState.powerPelletTimer = 0;\n    this.gameState.gameStatus = 'READY';\n  }\n  playSound(soundName) {\n    // Sound implementation would go here\n    // For now, just log the sound that would be played\n    console.log(`Playing sound: ${soundName}`);\n  }\n\n  // Public methods for external access\n\n  getGameState() {\n    return this.gameState;\n  }\n  startGame() {\n    this.gameState.gameStatus = 'PLAYING';\n  }\n  pauseGame() {\n    this.gameState.gameStatus = 'PAUSED';\n  }\n  resumeGame() {\n    this.gameState.gameStatus = 'PLAYING';\n  }\n  restartGame() {\n    this.gameState = this.initializeGameState();\n  }\n  toggleAIFeatures() {\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\n  }\n}","map":{"version":3,"names":["Direction","CellType","GhostState","GhostType","GAME_CONFIG","MAZE_LAYOUT","GHOST_CONFIG","PACMAN_START_POSITION","AIEngine","GameEngine","constructor","aiEngine","gameState","lastUpdateTime","frameCount","initializeGameState","maze","map","row","pelletsRemaining","countPellets","pacman","createPacMan","ghosts","createGhosts","score","highScore","parseInt","localStorage","getItem","lives","level","powerPelletActive","powerPelletTimer","gameStatus","ghostEatenCount","fruitSpawned","fruitPosition","fruitScore","aiLearningLevel","showAIFeatures","dangerMap","playerPatterns","screenShake","vhsGlitch","position","x","CELL_SIZE","y","velocity","dx","dy","direction","NONE","nextDirection","animationFrame","isDead","mouthOpen","Object","entries","type","config","id","startPosition","UP","state","CHASE","IN_HOUSE","color","targetPosition","scatterTarget","houseTimer","keys","indexOf","frightenedTimer","isFlashing","lastDirection","pathPrediction","update","currentTime","inputDirection","updatePacMan","updateGhosts","checkCollisions","updatePowerPelletTimer","updateAIAnalysis","checkGameConditions","updateVisualEffects","updateFruitSpawning","recordPlayerMovement","gridX","Math","round","gridY","nextGridPos","getNextPosition","isValidMove","setVelocity","nextX","nextY","MAZE_WIDTH","forEach","ghost","updateGhostState","updateGhostMovement","updateGhostAnimation","FRIGHTENED","GHOST_FLASH_DURATION","floor","EATEN","housePos","adaptGhostBehavior","modeTime","SCATTER","DOWN","setGhostVelocity","possibleDirections","getPossibleDirections","filter","dir","getOppositeDirection","length","bestDirection","shortestDistance","Infinity","random","nextPos","distance","manhattanDistance","predictions","predictGhostMovements","pacmanPos","cellType","PELLET","EMPTY","POINTS_PELLET","playSound","POWER_PELLET","POINTS_POWER_PELLET","activatePowerPellet","fruitPoints","POINTS_FRUIT","min","points","POINTS_GHOST_BASE","pow","setTimeout","resetPositions","POWER_PELLET_DURATION","generateDangerHeatmap","getLearningLevel","getPlayerPatterns","setItem","toString","getGhostTarget","BLINKY","PINKY","getPositionAhead","INKY","blinky","find","g","ahead","CLYDE","LEFT","RIGHT","max","MAZE_HEIGHT","directions","push","WALL","entity","speed","PACMAN_SPEED","GHOST_SPEED","FRIGHTENED_SPEED","pos1","pos2","abs","count","cell","soundName","console","log","getGameState","startGame","pauseGame","resumeGame","restartGame","toggleAIFeatures"],"sources":["C:/Users/VEDANT/Desktop/Src/Pacman/src/engine/GameEngine.ts"],"sourcesContent":["import {\r\n  GameState,\r\n  PacMan,\r\n  Ghost,\r\n  Position,\r\n  Direction,\r\n  CellType,\r\n  GhostState,\r\n  GhostType\r\n} from '../types/game.ts';\r\nimport {\r\n  GAME_CONFIG,\r\n  MAZE_LAYOUT,\r\n  GHOST_CONFIG,\r\n  PACMAN_START_POSITION\r\n} from '../config/gameConfig.ts';\r\nimport { AIEngine } from './AIEngine.ts';\r\n\r\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\r\nexport class GameEngine {\r\n  private aiEngine: AIEngine;\r\n  private gameState: GameState;\r\n  private lastUpdateTime: number = 0;\r\n  private frameCount: number = 0;\r\n\r\n  constructor() {\r\n    this.aiEngine = new AIEngine();\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  /**\r\n   * Initialize the game state with default values\r\n   */\r\n  private initializeGameState(): GameState {\r\n    const maze = MAZE_LAYOUT.map(row => [...row]);\r\n    const pelletsRemaining = this.countPellets(maze);\r\n\r\n    return {\r\n      pacman: this.createPacMan(),\r\n      ghosts: this.createGhosts(),\r\n      maze,\r\n      score: 0,\r\n      highScore: parseInt(localStorage.getItem('pacman-highscore') || '0'),\r\n      lives: 3,\r\n      level: 1,\r\n      pelletsRemaining,\r\n      powerPelletActive: false,\r\n      powerPelletTimer: 0,\r\n      gameStatus: 'READY',\r\n      ghostEatenCount: 0,\r\n      fruitSpawned: false,\r\n      fruitPosition: null,\r\n      fruitScore: 0,\r\n      aiLearningLevel: 0,\r\n      showAIFeatures: true,\r\n      dangerMap: [],\r\n      playerPatterns: [],\r\n      screenShake: false,\r\n      vhsGlitch: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\r\n  private createPacMan(): PacMan {\r\n    return {\r\n      position: { \r\n        x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE, \r\n        y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.NONE,\r\n      nextDirection: Direction.NONE,\r\n      animationFrame: 0,\r\n      isDead: false,\r\n      mouthOpen: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\r\n  private createGhosts(): Ghost[] {\r\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\r\n      id: type as GhostType,\r\n      position: { \r\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.UP,\r\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\r\n      color: config.color,\r\n      targetPosition: { \r\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      scatterTarget: { \r\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      houseTimer: type === 'BLINKY' ? 0 : 60 + (Object.keys(GHOST_CONFIG).indexOf(type) * 30),\r\n      frightenedTimer: 0,\r\n      isFlashing: false,\r\n      lastDirection: Direction.UP,\r\n      pathPrediction: []\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\r\n  update(currentTime: number, inputDirection: Direction): GameState {\r\n    // const deltaTime = currentTime - this.lastUpdateTime;\r\n    this.lastUpdateTime = currentTime;\r\n    this.frameCount++;\r\n\r\n    if (this.gameState.gameStatus !== 'PLAYING') {\r\n      return this.gameState;\r\n    }\r\n\r\n    // Update Pac-Man\r\n    this.updatePacMan(inputDirection);\r\n\r\n    // Update ghosts\r\n    this.updateGhosts();\r\n\r\n    // Check collisions\r\n    this.checkCollisions();\r\n\r\n    // Update power pellet timer\r\n    this.updatePowerPelletTimer();\r\n\r\n    // Update AI analysis\r\n    this.updateAIAnalysis();\r\n\r\n    // Check win/lose conditions\r\n    this.checkGameConditions();\r\n\r\n    // Update visual effects\r\n    this.updateVisualEffects();\r\n\r\n    // Spawn fruit occasionally\r\n    this.updateFruitSpawning();\r\n\r\n    return this.gameState;\r\n  }\r\n\r\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\r\n  private updatePacMan(inputDirection: Direction): void {\r\n    const pacman = this.gameState.pacman;\r\n\r\n    // Handle direction changes\r\n    if (inputDirection !== Direction.NONE) {\r\n      pacman.nextDirection = inputDirection;\r\n      \r\n      // Record movement for AI learning\r\n      this.aiEngine.recordPlayerMovement(inputDirection);\r\n    }\r\n\r\n    // Try to change direction if possible\r\n    if (pacman.nextDirection !== pacman.direction && pacman.nextDirection !== Direction.NONE) {\r\n      const gridX = Math.round(pacman.position.x / GAME_CONFIG.CELL_SIZE);\r\n      const gridY = Math.round(pacman.position.y / GAME_CONFIG.CELL_SIZE);\r\n      const nextGridPos = this.getNextPosition({ x: gridX, y: gridY }, pacman.nextDirection);\r\n      \r\n      if (this.isValidMove(nextGridPos)) {\r\n        pacman.direction = pacman.nextDirection;\r\n        this.setVelocity(pacman, pacman.direction);\r\n      }\r\n    }\r\n\r\n    // Move Pac-Man\r\n    if (pacman.direction !== Direction.NONE) {\r\n      let nextX = pacman.position.x + pacman.velocity.dx;\r\n      let nextY = pacman.position.y + pacman.velocity.dy;\r\n\r\n      // Handle tunnel wraparound\r\n      if (nextX < 0) {\r\n        nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\r\n      } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\r\n        nextX = 0;\r\n      }\r\n\r\n      // Check if move is valid by converting to grid coordinates\r\n      const gridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\r\n      const gridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\r\n      \r\n      if (this.isValidMove({ x: gridX, y: gridY })) {\r\n        pacman.position.x = nextX;\r\n        pacman.position.y = nextY;\r\n      } else {\r\n        // Stop if hitting wall\r\n        pacman.direction = Direction.NONE;\r\n        pacman.velocity = { dx: 0, dy: 0 };\r\n      }\r\n    }\r\n\r\n    // Update animation\r\n    if (this.frameCount % 8 === 0) {\r\n      pacman.mouthOpen = !pacman.mouthOpen;\r\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\r\n  private updateGhosts(): void {\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      this.updateGhostState(ghost);\r\n      this.updateGhostMovement(ghost);\r\n      this.updateGhostAnimation(ghost);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update individual ghost state and target\r\n   */\r\n  private updateGhostState(ghost: Ghost): void {\r\n    // Handle house timer\r\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\r\n      ghost.houseTimer--;\r\n      if (ghost.houseTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle frightened state\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      ghost.frightenedTimer--;\r\n      \r\n      // Start flashing when timer is low\r\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\r\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\r\n      }\r\n\r\n      if (ghost.frightenedTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n        ghost.isFlashing = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle eaten state\r\n    if (ghost.state === GhostState.EATEN) {\r\n      // Return to house\r\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\r\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      ghost.targetPosition = housePos;\r\n      return;\r\n    }\r\n\r\n    // Normal chase/scatter behavior with AI adaptation\r\n    // const baseTarget = this.getGhostTarget(ghost);\r\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(\r\n      ghost,\r\n      this.gameState.pacman,\r\n      this.gameState.ghosts\r\n    );\r\n\r\n    // Alternate between chase and scatter modes\r\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\r\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\r\n  }\r\n\r\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\r\n  private updateGhostMovement(ghost: Ghost): void {\r\n    if (ghost.state === GhostState.IN_HOUSE) {\r\n      // Simple up-down movement in house\r\n      if (this.frameCount % 60 < 30) {\r\n        ghost.direction = Direction.UP;\r\n      } else {\r\n        ghost.direction = Direction.DOWN;\r\n      }\r\n      this.setGhostVelocity(ghost);\r\n      return;\r\n    }\r\n\r\n    // Get possible directions (can't reverse unless frightened)\r\n    const possibleDirections = this.getPossibleDirections(ghost.position)\r\n      .filter(dir => {\r\n        if (ghost.state === GhostState.FRIGHTENED) return true;\r\n        return this.getOppositeDirection(dir) !== ghost.lastDirection;\r\n      });\r\n\r\n    if (possibleDirections.length === 0) return;\r\n\r\n    // Choose direction based on target\r\n    let bestDirection = possibleDirections[0];\r\n    let shortestDistance = Infinity;\r\n\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      // Random movement when frightened\r\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\r\n    } else {\r\n      // Move toward target\r\n      possibleDirections.forEach(direction => {\r\n        const nextPos = this.getNextPosition(ghost.position, direction);\r\n        const distance = this.manhattanDistance(nextPos, ghost.targetPosition);\r\n        \r\n        if (distance < shortestDistance) {\r\n          shortestDistance = distance;\r\n          bestDirection = direction;\r\n        }\r\n      });\r\n    }\r\n\r\n    ghost.lastDirection = ghost.direction;\r\n    ghost.direction = bestDirection;\r\n    this.setGhostVelocity(ghost);\r\n\r\n    // Move ghost\r\n    const nextPos = {\r\n      x: ghost.position.x + ghost.velocity.dx,\r\n      y: ghost.position.y + ghost.velocity.dy\r\n    };\r\n\r\n    // Handle tunnel wraparound\r\n    if (nextPos.x < 0) {\r\n      nextPos.x = GAME_CONFIG.MAZE_WIDTH - 1;\r\n    } else if (nextPos.x >= GAME_CONFIG.MAZE_WIDTH) {\r\n      nextPos.x = 0;\r\n    }\r\n\r\n    if (this.isValidMove(nextPos)) {\r\n      ghost.position = nextPos;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\r\n  private updateGhostAnimation(ghost: Ghost): void {\r\n    // Update path prediction for AI visualization\r\n    if (this.frameCount % 30 === 0) { // Update every half second\r\n      const predictions = this.aiEngine.predictGhostMovements(\r\n        [ghost],\r\n        this.gameState.maze,\r\n        this.gameState.pacman\r\n      );\r\n      ghost.pathPrediction = predictions[ghost.id] || [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\r\n  private checkCollisions(): void {\r\n    const pacmanPos = this.gameState.pacman.position;\r\n    const cellType = this.gameState.maze[pacmanPos.y][pacmanPos.x];\r\n\r\n    // Collect pellets\r\n    if (cellType === CellType.PELLET) {\r\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.playSound('CHOMP');\r\n    }\r\n\r\n    // Collect power pellets\r\n    if (cellType === CellType.POWER_PELLET) {\r\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.activatePowerPellet();\r\n      this.playSound('POWER_PELLET');\r\n    }\r\n\r\n    // Collect fruit\r\n    if (this.gameState.fruitPosition && \r\n        pacmanPos.x === this.gameState.fruitPosition.x && \r\n        pacmanPos.y === this.gameState.fruitPosition.y) {\r\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\r\n      this.gameState.score += fruitPoints;\r\n      this.gameState.fruitScore = fruitPoints;\r\n      this.gameState.fruitPosition = null;\r\n      this.gameState.fruitSpawned = false;\r\n      this.playSound('FRUIT');\r\n    }\r\n\r\n    // Check ghost collisions\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      if (this.manhattanDistance(pacmanPos, ghost.position) < 1) {\r\n        if (ghost.state === GhostState.FRIGHTENED) {\r\n          // Eat ghost\r\n          ghost.state = GhostState.EATEN;\r\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\r\n          this.gameState.score += points;\r\n          this.gameState.ghostEatenCount++;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('GHOST_EATEN');\r\n        } else if (ghost.state !== GhostState.EATEN) {\r\n          // Pac-Man dies\r\n          this.gameState.pacman.isDead = true;\r\n          this.gameState.lives--;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('DEATH');\r\n          \r\n          if (this.gameState.lives <= 0) {\r\n            this.gameState.gameStatus = 'GAME_OVER';\r\n          } else {\r\n            // Reset positions\r\n            setTimeout(() => this.resetPositions(), 2000);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate power pellet effect\r\n   */\r\n  private activatePowerPellet(): void {\r\n    this.gameState.powerPelletActive = true;\r\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n    this.gameState.ghostEatenCount = 0;\r\n\r\n    // Make ghosts frightened\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\r\n        ghost.state = GhostState.FRIGHTENED;\r\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n        ghost.isFlashing = false;\r\n        // Reverse direction\r\n        ghost.direction = this.getOppositeDirection(ghost.direction);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update power pellet timer\r\n   */\r\n  private updatePowerPelletTimer(): void {\r\n    if (this.gameState.powerPelletActive) {\r\n      this.gameState.powerPelletTimer--;\r\n      if (this.gameState.powerPelletTimer <= 0) {\r\n        this.gameState.powerPelletActive = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update AI analysis and danger map\r\n   */\r\n  private updateAIAnalysis(): void {\r\n    if (this.frameCount % 10 === 0) { // Update every 6th of a second\r\n      // const analysis = this.aiEngine.analyzeGameState(\r\n      //   this.gameState.pacman,\r\n      //   this.gameState.ghosts,\r\n      //   this.gameState.maze\r\n      // );\r\n\r\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(\r\n        this.gameState.ghosts,\r\n        this.gameState.maze\r\n      );\r\n\r\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\r\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check win/lose conditions\r\n   */\r\n  private checkGameConditions(): void {\r\n    // Check if all pellets collected\r\n    if (this.gameState.pelletsRemaining <= 0) {\r\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\r\n      this.gameState.level++;\r\n      \r\n      // Reset maze and positions for next level\r\n      setTimeout(() => {\r\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\r\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\r\n        this.resetPositions();\r\n        this.gameState.gameStatus = 'READY';\r\n      }, 2000);\r\n    }\r\n\r\n    // Update high score\r\n    if (this.gameState.score > this.gameState.highScore) {\r\n      this.gameState.highScore = this.gameState.score;\r\n      localStorage.setItem('pacman-highscore', this.gameState.score.toString());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update visual effects\r\n   */\r\n  private updateVisualEffects(): void {\r\n    // Reset screen shake\r\n    if (this.gameState.screenShake) {\r\n      setTimeout(() => {\r\n        this.gameState.screenShake = false;\r\n      }, 200);\r\n    }\r\n\r\n    // Random VHS glitch effect\r\n    if (Math.random() < 0.001) {\r\n      this.gameState.vhsGlitch = true;\r\n      setTimeout(() => {\r\n        this.gameState.vhsGlitch = false;\r\n      }, 100);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update fruit spawning logic\r\n   */\r\n  private updateFruitSpawning(): void {\r\n    if (!this.gameState.fruitSpawned && \r\n        this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\r\n      // Spawn fruit when 70% of pellets are eaten\r\n      this.gameState.fruitSpawned = true;\r\n      this.gameState.fruitPosition = { x: 9, y: 15 }; // Center of maze\r\n      \r\n      // Remove fruit after 10 seconds\r\n      setTimeout(() => {\r\n        this.gameState.fruitPosition = null;\r\n        this.gameState.fruitSpawned = false;\r\n      }, 10000);\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  private getGhostTarget(ghost: Ghost): Position {\r\n    const pacman = this.gameState.pacman;\r\n    \r\n    switch (ghost.id) {\r\n      case GhostType.BLINKY:\r\n        return pacman.position;\r\n        \r\n      case GhostType.PINKY:\r\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\r\n        \r\n      case GhostType.INKY:\r\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\r\n        if (blinky) {\r\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\r\n          return {\r\n            x: ahead.x + (ahead.x - blinky.position.x),\r\n            y: ahead.y + (ahead.y - blinky.position.y)\r\n          };\r\n        }\r\n        return pacman.position;\r\n        \r\n      case GhostType.CLYDE:\r\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\r\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\r\n        \r\n      default:\r\n        return pacman.position;\r\n    }\r\n  }\r\n\r\n  private getNextPosition(position: Position, direction: Direction): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - 1 };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + 1 };\r\n      case Direction.LEFT:\r\n        return { x: position.x - 1, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + 1, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getPositionAhead(position: Position, direction: Direction, distance: number): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: Math.max(0, position.y - distance) };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance) };\r\n      case Direction.LEFT:\r\n        return { x: Math.max(0, position.x - distance), y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance), y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getOppositeDirection(direction: Direction): Direction {\r\n    switch (direction) {\r\n      case Direction.UP: return Direction.DOWN;\r\n      case Direction.DOWN: return Direction.UP;\r\n      case Direction.LEFT: return Direction.RIGHT;\r\n      case Direction.RIGHT: return Direction.LEFT;\r\n      default: return Direction.NONE;\r\n    }\r\n  }\r\n\r\n  private getPossibleDirections(position: Position): Direction[] {\r\n    const directions: Direction[] = [];\r\n    \r\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\r\n      directions.push(Direction.UP);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\r\n      directions.push(Direction.DOWN);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\r\n      directions.push(Direction.LEFT);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\r\n      directions.push(Direction.RIGHT);\r\n    }\r\n\r\n    return directions;\r\n  }\r\n\r\n  private isValidMove(position: Position): boolean {\r\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\r\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\r\n    \r\n    const cellType = this.gameState.maze[position.y][position.x];\r\n    return cellType !== CellType.WALL;\r\n  }\r\n\r\n  private setVelocity(entity: PacMan, direction: Direction): void {\r\n    const speed = GAME_CONFIG.PACMAN_SPEED;\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        entity.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        entity.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        entity.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        entity.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        entity.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private setGhostVelocity(ghost: Ghost): void {\r\n    let speed = GAME_CONFIG.GHOST_SPEED;\r\n    \r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      speed = GAME_CONFIG.FRIGHTENED_SPEED;\r\n    } else if (ghost.state === GhostState.EATEN) {\r\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5; // Faster when returning to house\r\n    }\r\n\r\n    switch (ghost.direction) {\r\n      case Direction.UP:\r\n        ghost.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        ghost.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        ghost.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        ghost.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        ghost.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private manhattanDistance(pos1: Position, pos2: Position): number {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n  }\r\n\r\n  private countPellets(maze: CellType[][]): number {\r\n    let count = 0;\r\n    maze.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\r\n          count++;\r\n        }\r\n      });\r\n    });\r\n    return count;\r\n  }\r\n\r\n  private resetPositions(): void {\r\n    this.gameState.pacman.position = { ...PACMAN_START_POSITION };\r\n    this.gameState.pacman.direction = Direction.NONE;\r\n    this.gameState.pacman.velocity = { dx: 0, dy: 0 };\r\n    this.gameState.pacman.isDead = false;\r\n\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      ghost.position = { ...GHOST_CONFIG[ghost.id].startPosition };\r\n      ghost.direction = Direction.UP;\r\n      ghost.velocity = { dx: 0, dy: 0 };\r\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\r\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\r\n    });\r\n\r\n    this.gameState.powerPelletActive = false;\r\n    this.gameState.powerPelletTimer = 0;\r\n    this.gameState.gameStatus = 'READY';\r\n  }\r\n\r\n  private playSound(soundName: string): void {\r\n    // Sound implementation would go here\r\n    // For now, just log the sound that would be played\r\n    console.log(`Playing sound: ${soundName}`);\r\n  }\r\n\r\n  // Public methods for external access\r\n\r\n  getGameState(): GameState {\r\n    return this.gameState;\r\n  }\r\n\r\n  startGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  pauseGame(): void {\r\n    this.gameState.gameStatus = 'PAUSED';\r\n  }\r\n\r\n  resumeGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  restartGame(): void {\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  toggleAIFeatures(): void {\r\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}