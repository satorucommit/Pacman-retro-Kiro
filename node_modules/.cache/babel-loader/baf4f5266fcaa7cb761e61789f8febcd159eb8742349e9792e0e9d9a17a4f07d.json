{"ast":null,"code":"import{Direction,CellType,GhostState,GhostType}from'../types/game.ts';import{GAME_CONFIG,MAZE_LAYOUT,GHOST_CONFIG,PACMAN_START_POSITION}from'../config/gameConfig.ts';import{AIEngine}from'./AIEngine.ts';/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */export class GameEngine{constructor(){this.aiEngine=void 0;this.gameState=void 0;this.lastUpdateTime=0;this.frameCount=0;this.aiEngine=new AIEngine();this.gameState=this.initializeGameState();}/**\r\n   * Initialize the game state with default values\r\n   */initializeGameState(){const maze=MAZE_LAYOUT.map(row=>[...row]);const pelletsRemaining=this.countPellets(maze);return{pacman:this.createPacMan(),ghosts:this.createGhosts(),maze,score:0,highScore:parseInt(localStorage.getItem('pacman-highscore')||'0'),lives:3,level:1,pelletsRemaining,powerPelletActive:false,powerPelletTimer:0,gameStatus:'READY',ghostEatenCount:0,fruitSpawned:false,fruitPosition:null,fruitScore:0,aiLearningLevel:0,showAIFeatures:true,dangerMap:[],playerPatterns:[],screenShake:false,vhsGlitch:false};}/**\r\n   * Create Pac-Man with initial state\r\n   */createPacMan(){return{position:{x:PACMAN_START_POSITION.x*GAME_CONFIG.CELL_SIZE,y:PACMAN_START_POSITION.y*GAME_CONFIG.CELL_SIZE},velocity:{dx:0,dy:0},direction:Direction.NONE,nextDirection:Direction.NONE,animationFrame:0,isDead:false,mouthOpen:true};}/**\r\n   * Create all four ghosts with their unique properties\r\n   */createGhosts(){return Object.entries(GHOST_CONFIG).map(_ref=>{let[type,config]=_ref;return{id:type,position:{x:config.startPosition.x*GAME_CONFIG.CELL_SIZE,y:config.startPosition.y*GAME_CONFIG.CELL_SIZE},velocity:{dx:0,dy:0},direction:Direction.UP,state:type==='BLINKY'?GhostState.CHASE:GhostState.IN_HOUSE,color:config.color,targetPosition:{x:config.scatterTarget.x*GAME_CONFIG.CELL_SIZE,y:config.scatterTarget.y*GAME_CONFIG.CELL_SIZE},scatterTarget:{x:config.scatterTarget.x*GAME_CONFIG.CELL_SIZE,y:config.scatterTarget.y*GAME_CONFIG.CELL_SIZE},houseTimer:type==='BLINKY'?0:60+Object.keys(GHOST_CONFIG).indexOf(type)*30,frightenedTimer:0,isFlashing:false,lastDirection:Direction.UP,pathPrediction:[]};});}/**\r\n   * Main game update loop - called at 60fps\r\n   */update(currentTime,inputDirection){// const deltaTime = currentTime - this.lastUpdateTime;\nthis.lastUpdateTime=currentTime;this.frameCount++;if(this.gameState.gameStatus!=='PLAYING'){return this.gameState;}// Update Pac-Man\nthis.updatePacMan(inputDirection);// Update ghosts\nthis.updateGhosts();// Check collisions\nthis.checkCollisions();// Update power pellet timer\nthis.updatePowerPelletTimer();// Update AI analysis\nthis.updateAIAnalysis();// Check win/lose conditions\nthis.checkGameConditions();// Update visual effects\nthis.updateVisualEffects();// Spawn fruit occasionally\nthis.updateFruitSpawning();return this.gameState;}/**\r\n   * Update Pac-Man position and animation\r\n   */updatePacMan(inputDirection){const pacman=this.gameState.pacman;// Handle direction changes\nif(inputDirection!==Direction.NONE){pacman.nextDirection=inputDirection;// Record movement for AI learning\nthis.aiEngine.recordPlayerMovement(inputDirection);}// Try to change direction if possible\nif(pacman.nextDirection!==pacman.direction&&pacman.nextDirection!==Direction.NONE){const gridX=Math.round(pacman.position.x/GAME_CONFIG.CELL_SIZE);const gridY=Math.round(pacman.position.y/GAME_CONFIG.CELL_SIZE);const nextGridPos=this.getNextPosition({x:gridX,y:gridY},pacman.nextDirection);if(this.isValidMove(nextGridPos)){pacman.direction=pacman.nextDirection;this.setVelocity(pacman,pacman.direction);}}// Move Pac-Man\nif(pacman.direction!==Direction.NONE){let nextX=pacman.position.x+pacman.velocity.dx;let nextY=pacman.position.y+pacman.velocity.dy;// Handle tunnel wraparound\nif(nextX<0){nextX=(GAME_CONFIG.MAZE_WIDTH-1)*GAME_CONFIG.CELL_SIZE;}else if(nextX>=GAME_CONFIG.MAZE_WIDTH*GAME_CONFIG.CELL_SIZE){nextX=0;}// Check if move is valid by converting to grid coordinates\nconst gridX=Math.round(nextX/GAME_CONFIG.CELL_SIZE);const gridY=Math.round(nextY/GAME_CONFIG.CELL_SIZE);if(this.isValidMove({x:gridX,y:gridY})){pacman.position.x=nextX;pacman.position.y=nextY;}else{// Stop if hitting wall\npacman.direction=Direction.NONE;pacman.velocity={dx:0,dy:0};}}// Update animation\nif(this.frameCount%8===0){pacman.mouthOpen=!pacman.mouthOpen;pacman.animationFrame=(pacman.animationFrame+1)%4;}}/**\r\n   * Update all ghost positions and AI behavior\r\n   */updateGhosts(){this.gameState.ghosts.forEach(ghost=>{this.updateGhostState(ghost);this.updateGhostMovement(ghost);this.updateGhostAnimation(ghost);});}/**\r\n   * Update individual ghost state and target\r\n   */updateGhostState(ghost){// Handle house timer\nif(ghost.state===GhostState.IN_HOUSE&&ghost.houseTimer>0){ghost.houseTimer--;if(ghost.houseTimer<=0){ghost.state=GhostState.CHASE;}return;}// Handle frightened state\nif(ghost.state===GhostState.FRIGHTENED){ghost.frightenedTimer--;// Start flashing when timer is low\nif(ghost.frightenedTimer<=GAME_CONFIG.GHOST_FLASH_DURATION){ghost.isFlashing=Math.floor(ghost.frightenedTimer/10)%2===0;}if(ghost.frightenedTimer<=0){ghost.state=GhostState.CHASE;ghost.isFlashing=false;}return;}// Handle eaten state\nif(ghost.state===GhostState.EATEN){// Return to house\nconst housePos=GHOST_CONFIG[ghost.id].startPosition;if(ghost.position.x===housePos.x&&ghost.position.y===housePos.y){ghost.state=GhostState.CHASE;}ghost.targetPosition=housePos;return;}// Normal chase/scatter behavior with AI adaptation\n// const baseTarget = this.getGhostTarget(ghost);\nghost.targetPosition=this.aiEngine.adaptGhostBehavior(ghost,this.gameState.pacman,this.gameState.ghosts);// Alternate between chase and scatter modes\nconst modeTime=Math.floor(this.frameCount/600);// Change every 10 seconds\nghost.state=modeTime%2===0?GhostState.CHASE:GhostState.SCATTER;}/**\r\n   * Update ghost movement using pathfinding\r\n   */updateGhostMovement(ghost){if(ghost.state===GhostState.IN_HOUSE){// Simple up-down movement in house\nif(this.frameCount%60<30){ghost.direction=Direction.UP;}else{ghost.direction=Direction.DOWN;}this.setGhostVelocity(ghost);return;}// Convert ghost position to grid coordinates for pathfinding\nconst gridX=Math.round(ghost.position.x/GAME_CONFIG.CELL_SIZE);const gridY=Math.round(ghost.position.y/GAME_CONFIG.CELL_SIZE);const gridPos={x:gridX,y:gridY};// Get possible directions (can't reverse unless frightened)\nconst possibleDirections=this.getPossibleDirections(gridPos).filter(dir=>{if(ghost.state===GhostState.FRIGHTENED)return true;return this.getOppositeDirection(dir)!==ghost.lastDirection;});if(possibleDirections.length===0)return;// Choose direction based on target\nlet bestDirection=possibleDirections[0];let shortestDistance=Infinity;if(ghost.state===GhostState.FRIGHTENED){// Random movement when frightened\nbestDirection=possibleDirections[Math.floor(Math.random()*possibleDirections.length)];}else{// Move toward target\nconst targetGridX=Math.round(ghost.targetPosition.x/GAME_CONFIG.CELL_SIZE);const targetGridY=Math.round(ghost.targetPosition.y/GAME_CONFIG.CELL_SIZE);possibleDirections.forEach(direction=>{const nextPos=this.getNextPosition(gridPos,direction);const distance=this.manhattanDistance(nextPos,{x:targetGridX,y:targetGridY});if(distance<shortestDistance){shortestDistance=distance;bestDirection=direction;}});}ghost.lastDirection=ghost.direction;ghost.direction=bestDirection;this.setGhostVelocity(ghost);// Move ghost\nlet nextX=ghost.position.x+ghost.velocity.dx;let nextY=ghost.position.y+ghost.velocity.dy;// Handle tunnel wraparound\nif(nextX<0){nextX=(GAME_CONFIG.MAZE_WIDTH-1)*GAME_CONFIG.CELL_SIZE;}else if(nextX>=GAME_CONFIG.MAZE_WIDTH*GAME_CONFIG.CELL_SIZE){nextX=0;}// Check if move is valid by converting to grid coordinates\nconst nextGridX=Math.round(nextX/GAME_CONFIG.CELL_SIZE);const nextGridY=Math.round(nextY/GAME_CONFIG.CELL_SIZE);if(this.isValidMove({x:nextGridX,y:nextGridY})){ghost.position.x=nextX;ghost.position.y=nextY;}}/**\r\n   * Update ghost animation and visual effects\r\n   */updateGhostAnimation(ghost){// Update path prediction for AI visualization\nif(this.frameCount%30===0){// Update every half second\nconst predictions=this.aiEngine.predictGhostMovements([ghost],this.gameState.maze,this.gameState.pacman);ghost.pathPrediction=predictions[ghost.id]||[];}}/**\r\n   * Check collisions between Pac-Man and game elements\r\n   */checkCollisions(){const pacmanPos=this.gameState.pacman.position;const gridX=Math.round(pacmanPos.x/GAME_CONFIG.CELL_SIZE);const gridY=Math.round(pacmanPos.y/GAME_CONFIG.CELL_SIZE);// Ensure we're within bounds\nif(gridX<0||gridX>=GAME_CONFIG.MAZE_WIDTH||gridY<0||gridY>=GAME_CONFIG.MAZE_HEIGHT){return;}const cellType=this.gameState.maze[gridY][gridX];// Collect pellets\nif(cellType===CellType.PELLET){this.gameState.maze[gridY][gridX]=CellType.EMPTY;this.gameState.score+=GAME_CONFIG.POINTS_PELLET;this.gameState.pelletsRemaining--;this.playSound('CHOMP');}// Collect power pellets\nif(cellType===CellType.POWER_PELLET){this.gameState.maze[gridY][gridX]=CellType.EMPTY;this.gameState.score+=GAME_CONFIG.POINTS_POWER_PELLET;this.gameState.pelletsRemaining--;this.activatePowerPellet();this.playSound('POWER_PELLET');}// Collect fruit\nif(this.gameState.fruitPosition&&gridX===this.gameState.fruitPosition.x&&gridY===this.gameState.fruitPosition.y){const fruitPoints=GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level-1,7)];this.gameState.score+=fruitPoints;this.gameState.fruitScore=fruitPoints;this.gameState.fruitPosition=null;this.gameState.fruitSpawned=false;this.playSound('FRUIT');}// Check ghost collisions\nthis.gameState.ghosts.forEach(ghost=>{const ghostGridX=Math.round(ghost.position.x/GAME_CONFIG.CELL_SIZE);const ghostGridY=Math.round(ghost.position.y/GAME_CONFIG.CELL_SIZE);const distance=Math.abs(gridX-ghostGridX)+Math.abs(gridY-ghostGridY);if(distance<1){if(ghost.state===GhostState.FRIGHTENED){// Eat ghost\nghost.state=GhostState.EATEN;const points=GAME_CONFIG.POINTS_GHOST_BASE*Math.pow(2,this.gameState.ghostEatenCount);this.gameState.score+=points;this.gameState.ghostEatenCount++;this.gameState.screenShake=true;this.playSound('GHOST_EATEN');}else if(ghost.state!==GhostState.EATEN){// Pac-Man dies\nthis.gameState.pacman.isDead=true;this.gameState.lives--;this.gameState.screenShake=true;this.playSound('DEATH');if(this.gameState.lives<=0){this.gameState.gameStatus='GAME_OVER';}else{// Reset positions\nsetTimeout(()=>this.resetPositions(),2000);}}}});}/**\r\n   * Activate power pellet effect\r\n   */activatePowerPellet(){this.gameState.powerPelletActive=true;this.gameState.powerPelletTimer=GAME_CONFIG.POWER_PELLET_DURATION;this.gameState.ghostEatenCount=0;// Make ghosts frightened\nthis.gameState.ghosts.forEach(ghost=>{if(ghost.state!==GhostState.EATEN&&ghost.state!==GhostState.IN_HOUSE){ghost.state=GhostState.FRIGHTENED;ghost.frightenedTimer=GAME_CONFIG.POWER_PELLET_DURATION;ghost.isFlashing=false;// Reverse direction\nghost.direction=this.getOppositeDirection(ghost.direction);}});}/**\r\n   * Update power pellet timer\r\n   */updatePowerPelletTimer(){if(this.gameState.powerPelletActive){this.gameState.powerPelletTimer--;if(this.gameState.powerPelletTimer<=0){this.gameState.powerPelletActive=false;}}}/**\r\n   * Update AI analysis and danger map\r\n   */updateAIAnalysis(){if(this.frameCount%10===0){// Update every 6th of a second\n// const analysis = this.aiEngine.analyzeGameState(\n//   this.gameState.pacman,\n//   this.gameState.ghosts,\n//   this.gameState.maze\n// );\nthis.gameState.dangerMap=this.aiEngine.generateDangerHeatmap(this.gameState.ghosts,this.gameState.maze);this.gameState.aiLearningLevel=this.aiEngine.getLearningLevel();this.gameState.playerPatterns=this.aiEngine.getPlayerPatterns();}}/**\r\n   * Check win/lose conditions\r\n   */checkGameConditions(){// Check if all pellets collected\nif(this.gameState.pelletsRemaining<=0){this.gameState.gameStatus='LEVEL_COMPLETE';this.gameState.level++;// Reset maze and positions for next level\nsetTimeout(()=>{this.gameState.maze=MAZE_LAYOUT.map(row=>[...row]);this.gameState.pelletsRemaining=this.countPellets(this.gameState.maze);this.resetPositions();this.gameState.gameStatus='READY';},2000);}// Update high score\nif(this.gameState.score>this.gameState.highScore){this.gameState.highScore=this.gameState.score;localStorage.setItem('pacman-highscore',this.gameState.score.toString());}}/**\r\n   * Update visual effects\r\n   */updateVisualEffects(){// Reset screen shake\nif(this.gameState.screenShake){setTimeout(()=>{this.gameState.screenShake=false;},200);}// Random VHS glitch effect\nif(Math.random()<0.001){this.gameState.vhsGlitch=true;setTimeout(()=>{this.gameState.vhsGlitch=false;},100);}}/**\r\n   * Update fruit spawning logic\r\n   */updateFruitSpawning(){if(!this.gameState.fruitSpawned&&this.gameState.pelletsRemaining<this.countPellets(MAZE_LAYOUT)*0.7){// Spawn fruit when 70% of pellets are eaten\nthis.gameState.fruitSpawned=true;this.gameState.fruitPosition={x:9,y:15};// Center of maze (grid coordinates)\n// Remove fruit after 10 seconds\nsetTimeout(()=>{this.gameState.fruitPosition=null;this.gameState.fruitSpawned=false;},10000);}}// Helper methods\ngetGhostTarget(ghost){const pacman=this.gameState.pacman;switch(ghost.id){case GhostType.BLINKY:return pacman.position;case GhostType.PINKY:return this.getPositionAhead(pacman.position,pacman.direction,4);case GhostType.INKY:const blinky=this.gameState.ghosts.find(g=>g.id===GhostType.BLINKY);if(blinky){const ahead=this.getPositionAhead(pacman.position,pacman.direction,2);return{x:ahead.x+(ahead.x-blinky.position.x),y:ahead.y+(ahead.y-blinky.position.y)};}return pacman.position;case GhostType.CLYDE:const distance=this.manhattanDistance(ghost.position,pacman.position);return distance>8?pacman.position:ghost.scatterTarget;default:return pacman.position;}}getNextPosition(position,direction){switch(direction){case Direction.UP:return{x:position.x,y:position.y-1};case Direction.DOWN:return{x:position.x,y:position.y+1};case Direction.LEFT:return{x:position.x-1,y:position.y};case Direction.RIGHT:return{x:position.x+1,y:position.y};default:return position;}}getPositionAhead(position,direction,distance){switch(direction){case Direction.UP:return{x:position.x,y:Math.max(0,position.y-distance)};case Direction.DOWN:return{x:position.x,y:Math.min(GAME_CONFIG.MAZE_HEIGHT-1,position.y+distance)};case Direction.LEFT:return{x:Math.max(0,position.x-distance),y:position.y};case Direction.RIGHT:return{x:Math.min(GAME_CONFIG.MAZE_WIDTH-1,position.x+distance),y:position.y};default:return position;}}getOppositeDirection(direction){switch(direction){case Direction.UP:return Direction.DOWN;case Direction.DOWN:return Direction.UP;case Direction.LEFT:return Direction.RIGHT;case Direction.RIGHT:return Direction.LEFT;default:return Direction.NONE;}}getPossibleDirections(position){const directions=[];if(this.isValidMove(this.getNextPosition(position,Direction.UP))){directions.push(Direction.UP);}if(this.isValidMove(this.getNextPosition(position,Direction.DOWN))){directions.push(Direction.DOWN);}if(this.isValidMove(this.getNextPosition(position,Direction.LEFT))){directions.push(Direction.LEFT);}if(this.isValidMove(this.getNextPosition(position,Direction.RIGHT))){directions.push(Direction.RIGHT);}return directions;}isValidMove(position){if(position.y<0||position.y>=GAME_CONFIG.MAZE_HEIGHT)return false;if(position.x<0||position.x>=GAME_CONFIG.MAZE_WIDTH)return false;const cellType=this.gameState.maze[position.y][position.x];return cellType!==CellType.WALL;}setVelocity(entity,direction){const speed=GAME_CONFIG.PACMAN_SPEED;switch(direction){case Direction.UP:entity.velocity={dx:0,dy:-speed};break;case Direction.DOWN:entity.velocity={dx:0,dy:speed};break;case Direction.LEFT:entity.velocity={dx:-speed,dy:0};break;case Direction.RIGHT:entity.velocity={dx:speed,dy:0};break;default:entity.velocity={dx:0,dy:0};}}setGhostVelocity(ghost){let speed=GAME_CONFIG.GHOST_SPEED;if(ghost.state===GhostState.FRIGHTENED){speed=GAME_CONFIG.FRIGHTENED_SPEED;}else if(ghost.state===GhostState.EATEN){speed=GAME_CONFIG.GHOST_SPEED*1.5;// Faster when returning to house\n}switch(ghost.direction){case Direction.UP:ghost.velocity={dx:0,dy:-speed};break;case Direction.DOWN:ghost.velocity={dx:0,dy:speed};break;case Direction.LEFT:ghost.velocity={dx:-speed,dy:0};break;case Direction.RIGHT:ghost.velocity={dx:speed,dy:0};break;default:ghost.velocity={dx:0,dy:0};}}manhattanDistance(pos1,pos2){return Math.abs(pos1.x-pos2.x)+Math.abs(pos1.y-pos2.y);}countPellets(maze){let count=0;maze.forEach(row=>{row.forEach(cell=>{if(cell===CellType.PELLET||cell===CellType.POWER_PELLET){count++;}});});return count;}resetPositions(){this.gameState.pacman.position={x:PACMAN_START_POSITION.x*GAME_CONFIG.CELL_SIZE,y:PACMAN_START_POSITION.y*GAME_CONFIG.CELL_SIZE};this.gameState.pacman.direction=Direction.NONE;this.gameState.pacman.velocity={dx:0,dy:0};this.gameState.pacman.isDead=false;this.gameState.ghosts.forEach(ghost=>{const config=GHOST_CONFIG[ghost.id];ghost.position={x:config.startPosition.x*GAME_CONFIG.CELL_SIZE,y:config.startPosition.y*GAME_CONFIG.CELL_SIZE};ghost.direction=Direction.UP;ghost.velocity={dx:0,dy:0};ghost.state=ghost.id===GhostType.BLINKY?GhostState.CHASE:GhostState.IN_HOUSE;ghost.houseTimer=ghost.id===GhostType.BLINKY?0:60;});this.gameState.powerPelletActive=false;this.gameState.powerPelletTimer=0;this.gameState.gameStatus='READY';}playSound(soundName){// Sound implementation would go here\n// For now, just log the sound that would be played\nconsole.log(\"Playing sound: \".concat(soundName));}// Public methods for external access\ngetGameState(){return this.gameState;}startGame(){this.gameState.gameStatus='PLAYING';}pauseGame(){this.gameState.gameStatus='PAUSED';}resumeGame(){this.gameState.gameStatus='PLAYING';}restartGame(){this.gameState=this.initializeGameState();}toggleAIFeatures(){this.gameState.showAIFeatures=!this.gameState.showAIFeatures;}}","map":{"version":3,"names":["Direction","CellType","GhostState","GhostType","GAME_CONFIG","MAZE_LAYOUT","GHOST_CONFIG","PACMAN_START_POSITION","AIEngine","GameEngine","constructor","aiEngine","gameState","lastUpdateTime","frameCount","initializeGameState","maze","map","row","pelletsRemaining","countPellets","pacman","createPacMan","ghosts","createGhosts","score","highScore","parseInt","localStorage","getItem","lives","level","powerPelletActive","powerPelletTimer","gameStatus","ghostEatenCount","fruitSpawned","fruitPosition","fruitScore","aiLearningLevel","showAIFeatures","dangerMap","playerPatterns","screenShake","vhsGlitch","position","x","CELL_SIZE","y","velocity","dx","dy","direction","NONE","nextDirection","animationFrame","isDead","mouthOpen","Object","entries","_ref","type","config","id","startPosition","UP","state","CHASE","IN_HOUSE","color","targetPosition","scatterTarget","houseTimer","keys","indexOf","frightenedTimer","isFlashing","lastDirection","pathPrediction","update","currentTime","inputDirection","updatePacMan","updateGhosts","checkCollisions","updatePowerPelletTimer","updateAIAnalysis","checkGameConditions","updateVisualEffects","updateFruitSpawning","recordPlayerMovement","gridX","Math","round","gridY","nextGridPos","getNextPosition","isValidMove","setVelocity","nextX","nextY","MAZE_WIDTH","forEach","ghost","updateGhostState","updateGhostMovement","updateGhostAnimation","FRIGHTENED","GHOST_FLASH_DURATION","floor","EATEN","housePos","adaptGhostBehavior","modeTime","SCATTER","DOWN","setGhostVelocity","gridPos","possibleDirections","getPossibleDirections","filter","dir","getOppositeDirection","length","bestDirection","shortestDistance","Infinity","random","targetGridX","targetGridY","nextPos","distance","manhattanDistance","nextGridX","nextGridY","predictions","predictGhostMovements","pacmanPos","MAZE_HEIGHT","cellType","PELLET","EMPTY","POINTS_PELLET","playSound","POWER_PELLET","POINTS_POWER_PELLET","activatePowerPellet","fruitPoints","POINTS_FRUIT","min","ghostGridX","ghostGridY","abs","points","POINTS_GHOST_BASE","pow","setTimeout","resetPositions","POWER_PELLET_DURATION","generateDangerHeatmap","getLearningLevel","getPlayerPatterns","setItem","toString","getGhostTarget","BLINKY","PINKY","getPositionAhead","INKY","blinky","find","g","ahead","CLYDE","LEFT","RIGHT","max","directions","push","WALL","entity","speed","PACMAN_SPEED","GHOST_SPEED","FRIGHTENED_SPEED","pos1","pos2","count","cell","soundName","console","log","concat","getGameState","startGame","pauseGame","resumeGame","restartGame","toggleAIFeatures"],"sources":["C:/Users/VEDANT/Desktop/Src/Pacman/src/engine/GameEngine.ts"],"sourcesContent":["import {\r\n  GameState,\r\n  PacMan,\r\n  Ghost,\r\n  Position,\r\n  Direction,\r\n  CellType,\r\n  GhostState,\r\n  GhostType\r\n} from '../types/game.ts';\r\nimport {\r\n  GAME_CONFIG,\r\n  MAZE_LAYOUT,\r\n  GHOST_CONFIG,\r\n  PACMAN_START_POSITION\r\n} from '../config/gameConfig.ts';\r\nimport { AIEngine } from './AIEngine.ts';\r\n\r\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\r\nexport class GameEngine {\r\n  private aiEngine: AIEngine;\r\n  private gameState: GameState;\r\n  private lastUpdateTime: number = 0;\r\n  private frameCount: number = 0;\r\n\r\n  constructor() {\r\n    this.aiEngine = new AIEngine();\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  /**\r\n   * Initialize the game state with default values\r\n   */\r\n  private initializeGameState(): GameState {\r\n    const maze = MAZE_LAYOUT.map(row => [...row]);\r\n    const pelletsRemaining = this.countPellets(maze);\r\n\r\n    return {\r\n      pacman: this.createPacMan(),\r\n      ghosts: this.createGhosts(),\r\n      maze,\r\n      score: 0,\r\n      highScore: parseInt(localStorage.getItem('pacman-highscore') || '0'),\r\n      lives: 3,\r\n      level: 1,\r\n      pelletsRemaining,\r\n      powerPelletActive: false,\r\n      powerPelletTimer: 0,\r\n      gameStatus: 'READY',\r\n      ghostEatenCount: 0,\r\n      fruitSpawned: false,\r\n      fruitPosition: null,\r\n      fruitScore: 0,\r\n      aiLearningLevel: 0,\r\n      showAIFeatures: true,\r\n      dangerMap: [],\r\n      playerPatterns: [],\r\n      screenShake: false,\r\n      vhsGlitch: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\r\n  private createPacMan(): PacMan {\r\n    return {\r\n      position: { \r\n        x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE, \r\n        y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.NONE,\r\n      nextDirection: Direction.NONE,\r\n      animationFrame: 0,\r\n      isDead: false,\r\n      mouthOpen: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\r\n  private createGhosts(): Ghost[] {\r\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\r\n      id: type as GhostType,\r\n      position: { \r\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.UP,\r\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\r\n      color: config.color,\r\n      targetPosition: { \r\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      scatterTarget: { \r\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE \r\n      },\r\n      houseTimer: type === 'BLINKY' ? 0 : 60 + (Object.keys(GHOST_CONFIG).indexOf(type) * 30),\r\n      frightenedTimer: 0,\r\n      isFlashing: false,\r\n      lastDirection: Direction.UP,\r\n      pathPrediction: []\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\r\n  update(currentTime: number, inputDirection: Direction): GameState {\r\n    // const deltaTime = currentTime - this.lastUpdateTime;\r\n    this.lastUpdateTime = currentTime;\r\n    this.frameCount++;\r\n\r\n    if (this.gameState.gameStatus !== 'PLAYING') {\r\n      return this.gameState;\r\n    }\r\n\r\n    // Update Pac-Man\r\n    this.updatePacMan(inputDirection);\r\n\r\n    // Update ghosts\r\n    this.updateGhosts();\r\n\r\n    // Check collisions\r\n    this.checkCollisions();\r\n\r\n    // Update power pellet timer\r\n    this.updatePowerPelletTimer();\r\n\r\n    // Update AI analysis\r\n    this.updateAIAnalysis();\r\n\r\n    // Check win/lose conditions\r\n    this.checkGameConditions();\r\n\r\n    // Update visual effects\r\n    this.updateVisualEffects();\r\n\r\n    // Spawn fruit occasionally\r\n    this.updateFruitSpawning();\r\n\r\n    return this.gameState;\r\n  }\r\n\r\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\r\n  private updatePacMan(inputDirection: Direction): void {\r\n    const pacman = this.gameState.pacman;\r\n\r\n    // Handle direction changes\r\n    if (inputDirection !== Direction.NONE) {\r\n      pacman.nextDirection = inputDirection;\r\n      \r\n      // Record movement for AI learning\r\n      this.aiEngine.recordPlayerMovement(inputDirection);\r\n    }\r\n\r\n    // Try to change direction if possible\r\n    if (pacman.nextDirection !== pacman.direction && pacman.nextDirection !== Direction.NONE) {\r\n      const gridX = Math.round(pacman.position.x / GAME_CONFIG.CELL_SIZE);\r\n      const gridY = Math.round(pacman.position.y / GAME_CONFIG.CELL_SIZE);\r\n      const nextGridPos = this.getNextPosition({ x: gridX, y: gridY }, pacman.nextDirection);\r\n      \r\n      if (this.isValidMove(nextGridPos)) {\r\n        pacman.direction = pacman.nextDirection;\r\n        this.setVelocity(pacman, pacman.direction);\r\n      }\r\n    }\r\n\r\n    // Move Pac-Man\r\n    if (pacman.direction !== Direction.NONE) {\r\n      let nextX = pacman.position.x + pacman.velocity.dx;\r\n      let nextY = pacman.position.y + pacman.velocity.dy;\r\n\r\n      // Handle tunnel wraparound\r\n      if (nextX < 0) {\r\n        nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\r\n      } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\r\n        nextX = 0;\r\n      }\r\n\r\n      // Check if move is valid by converting to grid coordinates\r\n      const gridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\r\n      const gridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\r\n      \r\n      if (this.isValidMove({ x: gridX, y: gridY })) {\r\n        pacman.position.x = nextX;\r\n        pacman.position.y = nextY;\r\n      } else {\r\n        // Stop if hitting wall\r\n        pacman.direction = Direction.NONE;\r\n        pacman.velocity = { dx: 0, dy: 0 };\r\n      }\r\n    }\r\n\r\n    // Update animation\r\n    if (this.frameCount % 8 === 0) {\r\n      pacman.mouthOpen = !pacman.mouthOpen;\r\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\r\n  private updateGhosts(): void {\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      this.updateGhostState(ghost);\r\n      this.updateGhostMovement(ghost);\r\n      this.updateGhostAnimation(ghost);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update individual ghost state and target\r\n   */\r\n  private updateGhostState(ghost: Ghost): void {\r\n    // Handle house timer\r\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\r\n      ghost.houseTimer--;\r\n      if (ghost.houseTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle frightened state\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      ghost.frightenedTimer--;\r\n      \r\n      // Start flashing when timer is low\r\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\r\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\r\n      }\r\n\r\n      if (ghost.frightenedTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n        ghost.isFlashing = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle eaten state\r\n    if (ghost.state === GhostState.EATEN) {\r\n      // Return to house\r\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\r\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      ghost.targetPosition = housePos;\r\n      return;\r\n    }\r\n\r\n    // Normal chase/scatter behavior with AI adaptation\r\n    // const baseTarget = this.getGhostTarget(ghost);\r\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(\r\n      ghost,\r\n      this.gameState.pacman,\r\n      this.gameState.ghosts\r\n    );\r\n\r\n    // Alternate between chase and scatter modes\r\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\r\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\r\n  }\r\n\r\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\r\n  private updateGhostMovement(ghost: Ghost): void {\r\n    if (ghost.state === GhostState.IN_HOUSE) {\r\n      // Simple up-down movement in house\r\n      if (this.frameCount % 60 < 30) {\r\n        ghost.direction = Direction.UP;\r\n      } else {\r\n        ghost.direction = Direction.DOWN;\r\n      }\r\n      this.setGhostVelocity(ghost);\r\n      return;\r\n    }\r\n\r\n    // Convert ghost position to grid coordinates for pathfinding\r\n    const gridX = Math.round(ghost.position.x / GAME_CONFIG.CELL_SIZE);\r\n    const gridY = Math.round(ghost.position.y / GAME_CONFIG.CELL_SIZE);\r\n    const gridPos = { x: gridX, y: gridY };\r\n\r\n    // Get possible directions (can't reverse unless frightened)\r\n    const possibleDirections = this.getPossibleDirections(gridPos)\r\n      .filter(dir => {\r\n        if (ghost.state === GhostState.FRIGHTENED) return true;\r\n        return this.getOppositeDirection(dir) !== ghost.lastDirection;\r\n      });\r\n\r\n    if (possibleDirections.length === 0) return;\r\n\r\n    // Choose direction based on target\r\n    let bestDirection = possibleDirections[0];\r\n    let shortestDistance = Infinity;\r\n\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      // Random movement when frightened\r\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\r\n    } else {\r\n      // Move toward target\r\n      const targetGridX = Math.round(ghost.targetPosition.x / GAME_CONFIG.CELL_SIZE);\r\n      const targetGridY = Math.round(ghost.targetPosition.y / GAME_CONFIG.CELL_SIZE);\r\n      \r\n      possibleDirections.forEach(direction => {\r\n        const nextPos = this.getNextPosition(gridPos, direction);\r\n        const distance = this.manhattanDistance(nextPos, { x: targetGridX, y: targetGridY });\r\n        \r\n        if (distance < shortestDistance) {\r\n          shortestDistance = distance;\r\n          bestDirection = direction;\r\n        }\r\n      });\r\n    }\r\n\r\n    ghost.lastDirection = ghost.direction;\r\n    ghost.direction = bestDirection;\r\n    this.setGhostVelocity(ghost);\r\n\r\n    // Move ghost\r\n    let nextX = ghost.position.x + ghost.velocity.dx;\r\n    let nextY = ghost.position.y + ghost.velocity.dy;\r\n\r\n    // Handle tunnel wraparound\r\n    if (nextX < 0) {\r\n      nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\r\n    } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\r\n      nextX = 0;\r\n    }\r\n\r\n    // Check if move is valid by converting to grid coordinates\r\n    const nextGridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\r\n    const nextGridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\r\n    \r\n    if (this.isValidMove({ x: nextGridX, y: nextGridY })) {\r\n      ghost.position.x = nextX;\r\n      ghost.position.y = nextY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\r\n  private updateGhostAnimation(ghost: Ghost): void {\r\n    // Update path prediction for AI visualization\r\n    if (this.frameCount % 30 === 0) { // Update every half second\r\n      const predictions = this.aiEngine.predictGhostMovements(\r\n        [ghost],\r\n        this.gameState.maze,\r\n        this.gameState.pacman\r\n      );\r\n      ghost.pathPrediction = predictions[ghost.id] || [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\r\n  private checkCollisions(): void {\r\n    const pacmanPos = this.gameState.pacman.position;\r\n    const gridX = Math.round(pacmanPos.x / GAME_CONFIG.CELL_SIZE);\r\n    const gridY = Math.round(pacmanPos.y / GAME_CONFIG.CELL_SIZE);\r\n    \r\n    // Ensure we're within bounds\r\n    if (gridX < 0 || gridX >= GAME_CONFIG.MAZE_WIDTH || gridY < 0 || gridY >= GAME_CONFIG.MAZE_HEIGHT) {\r\n      return;\r\n    }\r\n    \r\n    const cellType = this.gameState.maze[gridY][gridX];\r\n\r\n    // Collect pellets\r\n    if (cellType === CellType.PELLET) {\r\n      this.gameState.maze[gridY][gridX] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.playSound('CHOMP');\r\n    }\r\n\r\n    // Collect power pellets\r\n    if (cellType === CellType.POWER_PELLET) {\r\n      this.gameState.maze[gridY][gridX] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.activatePowerPellet();\r\n      this.playSound('POWER_PELLET');\r\n    }\r\n\r\n    // Collect fruit\r\n    if (this.gameState.fruitPosition && \r\n        gridX === this.gameState.fruitPosition.x && \r\n        gridY === this.gameState.fruitPosition.y) {\r\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\r\n      this.gameState.score += fruitPoints;\r\n      this.gameState.fruitScore = fruitPoints;\r\n      this.gameState.fruitPosition = null;\r\n      this.gameState.fruitSpawned = false;\r\n      this.playSound('FRUIT');\r\n    }\r\n\r\n    // Check ghost collisions\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      const ghostGridX = Math.round(ghost.position.x / GAME_CONFIG.CELL_SIZE);\r\n      const ghostGridY = Math.round(ghost.position.y / GAME_CONFIG.CELL_SIZE);\r\n      const distance = Math.abs(gridX - ghostGridX) + Math.abs(gridY - ghostGridY);\r\n      \r\n      if (distance < 1) {\r\n        if (ghost.state === GhostState.FRIGHTENED) {\r\n          // Eat ghost\r\n          ghost.state = GhostState.EATEN;\r\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\r\n          this.gameState.score += points;\r\n          this.gameState.ghostEatenCount++;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('GHOST_EATEN');\r\n        } else if (ghost.state !== GhostState.EATEN) {\r\n          // Pac-Man dies\r\n          this.gameState.pacman.isDead = true;\r\n          this.gameState.lives--;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('DEATH');\r\n          \r\n          if (this.gameState.lives <= 0) {\r\n            this.gameState.gameStatus = 'GAME_OVER';\r\n          } else {\r\n            // Reset positions\r\n            setTimeout(() => this.resetPositions(), 2000);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate power pellet effect\r\n   */\r\n  private activatePowerPellet(): void {\r\n    this.gameState.powerPelletActive = true;\r\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n    this.gameState.ghostEatenCount = 0;\r\n\r\n    // Make ghosts frightened\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\r\n        ghost.state = GhostState.FRIGHTENED;\r\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n        ghost.isFlashing = false;\r\n        // Reverse direction\r\n        ghost.direction = this.getOppositeDirection(ghost.direction);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update power pellet timer\r\n   */\r\n  private updatePowerPelletTimer(): void {\r\n    if (this.gameState.powerPelletActive) {\r\n      this.gameState.powerPelletTimer--;\r\n      if (this.gameState.powerPelletTimer <= 0) {\r\n        this.gameState.powerPelletActive = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update AI analysis and danger map\r\n   */\r\n  private updateAIAnalysis(): void {\r\n    if (this.frameCount % 10 === 0) { // Update every 6th of a second\r\n      // const analysis = this.aiEngine.analyzeGameState(\r\n      //   this.gameState.pacman,\r\n      //   this.gameState.ghosts,\r\n      //   this.gameState.maze\r\n      // );\r\n\r\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(\r\n        this.gameState.ghosts,\r\n        this.gameState.maze\r\n      );\r\n\r\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\r\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check win/lose conditions\r\n   */\r\n  private checkGameConditions(): void {\r\n    // Check if all pellets collected\r\n    if (this.gameState.pelletsRemaining <= 0) {\r\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\r\n      this.gameState.level++;\r\n      \r\n      // Reset maze and positions for next level\r\n      setTimeout(() => {\r\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\r\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\r\n        this.resetPositions();\r\n        this.gameState.gameStatus = 'READY';\r\n      }, 2000);\r\n    }\r\n\r\n    // Update high score\r\n    if (this.gameState.score > this.gameState.highScore) {\r\n      this.gameState.highScore = this.gameState.score;\r\n      localStorage.setItem('pacman-highscore', this.gameState.score.toString());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update visual effects\r\n   */\r\n  private updateVisualEffects(): void {\r\n    // Reset screen shake\r\n    if (this.gameState.screenShake) {\r\n      setTimeout(() => {\r\n        this.gameState.screenShake = false;\r\n      }, 200);\r\n    }\r\n\r\n    // Random VHS glitch effect\r\n    if (Math.random() < 0.001) {\r\n      this.gameState.vhsGlitch = true;\r\n      setTimeout(() => {\r\n        this.gameState.vhsGlitch = false;\r\n      }, 100);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update fruit spawning logic\r\n   */\r\n  private updateFruitSpawning(): void {\r\n    if (!this.gameState.fruitSpawned && \r\n        this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\r\n      // Spawn fruit when 70% of pellets are eaten\r\n      this.gameState.fruitSpawned = true;\r\n      this.gameState.fruitPosition = { x: 9, y: 15 }; // Center of maze (grid coordinates)\r\n      \r\n      // Remove fruit after 10 seconds\r\n      setTimeout(() => {\r\n        this.gameState.fruitPosition = null;\r\n        this.gameState.fruitSpawned = false;\r\n      }, 10000);\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  private getGhostTarget(ghost: Ghost): Position {\r\n    const pacman = this.gameState.pacman;\r\n    \r\n    switch (ghost.id) {\r\n      case GhostType.BLINKY:\r\n        return pacman.position;\r\n        \r\n      case GhostType.PINKY:\r\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\r\n        \r\n      case GhostType.INKY:\r\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\r\n        if (blinky) {\r\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\r\n          return {\r\n            x: ahead.x + (ahead.x - blinky.position.x),\r\n            y: ahead.y + (ahead.y - blinky.position.y)\r\n          };\r\n        }\r\n        return pacman.position;\r\n        \r\n      case GhostType.CLYDE:\r\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\r\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\r\n        \r\n      default:\r\n        return pacman.position;\r\n    }\r\n  }\r\n\r\n  private getNextPosition(position: Position, direction: Direction): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - 1 };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + 1 };\r\n      case Direction.LEFT:\r\n        return { x: position.x - 1, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + 1, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getPositionAhead(position: Position, direction: Direction, distance: number): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: Math.max(0, position.y - distance) };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance) };\r\n      case Direction.LEFT:\r\n        return { x: Math.max(0, position.x - distance), y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance), y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getOppositeDirection(direction: Direction): Direction {\r\n    switch (direction) {\r\n      case Direction.UP: return Direction.DOWN;\r\n      case Direction.DOWN: return Direction.UP;\r\n      case Direction.LEFT: return Direction.RIGHT;\r\n      case Direction.RIGHT: return Direction.LEFT;\r\n      default: return Direction.NONE;\r\n    }\r\n  }\r\n\r\n  private getPossibleDirections(position: Position): Direction[] {\r\n    const directions: Direction[] = [];\r\n    \r\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\r\n      directions.push(Direction.UP);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\r\n      directions.push(Direction.DOWN);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\r\n      directions.push(Direction.LEFT);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\r\n      directions.push(Direction.RIGHT);\r\n    }\r\n\r\n    return directions;\r\n  }\r\n\r\n  private isValidMove(position: Position): boolean {\r\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\r\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\r\n    \r\n    const cellType = this.gameState.maze[position.y][position.x];\r\n    return cellType !== CellType.WALL;\r\n  }\r\n\r\n  private setVelocity(entity: PacMan, direction: Direction): void {\r\n    const speed = GAME_CONFIG.PACMAN_SPEED;\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        entity.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        entity.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        entity.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        entity.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        entity.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private setGhostVelocity(ghost: Ghost): void {\r\n    let speed = GAME_CONFIG.GHOST_SPEED;\r\n    \r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      speed = GAME_CONFIG.FRIGHTENED_SPEED;\r\n    } else if (ghost.state === GhostState.EATEN) {\r\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5; // Faster when returning to house\r\n    }\r\n\r\n    switch (ghost.direction) {\r\n      case Direction.UP:\r\n        ghost.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        ghost.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        ghost.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        ghost.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        ghost.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private manhattanDistance(pos1: Position, pos2: Position): number {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n  }\r\n\r\n  private countPellets(maze: CellType[][]): number {\r\n    let count = 0;\r\n    maze.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\r\n          count++;\r\n        }\r\n      });\r\n    });\r\n    return count;\r\n  }\r\n\r\n  private resetPositions(): void {\r\n    this.gameState.pacman.position = { \r\n      x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE, \r\n      y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE \r\n    };\r\n    this.gameState.pacman.direction = Direction.NONE;\r\n    this.gameState.pacman.velocity = { dx: 0, dy: 0 };\r\n    this.gameState.pacman.isDead = false;\r\n\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      const config = GHOST_CONFIG[ghost.id];\r\n      ghost.position = { \r\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE, \r\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE \r\n      };\r\n      ghost.direction = Direction.UP;\r\n      ghost.velocity = { dx: 0, dy: 0 };\r\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\r\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\r\n    });\r\n\r\n    this.gameState.powerPelletActive = false;\r\n    this.gameState.powerPelletTimer = 0;\r\n    this.gameState.gameStatus = 'READY';\r\n  }\r\n\r\n  private playSound(soundName: string): void {\r\n    // Sound implementation would go here\r\n    // For now, just log the sound that would be played\r\n    console.log(`Playing sound: ${soundName}`);\r\n  }\r\n\r\n  // Public methods for external access\r\n\r\n  getGameState(): GameState {\r\n    return this.gameState;\r\n  }\r\n\r\n  startGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  pauseGame(): void {\r\n    this.gameState.gameStatus = 'PAUSED';\r\n  }\r\n\r\n  resumeGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  restartGame(): void {\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  toggleAIFeatures(): void {\r\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}