{"ast":null,"code":"import _objectSpread from\"C:/Users/VEDANT/Desktop/Src/Pacman/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{Direction,CellType,GhostState,GhostType}from'../types/game.ts';import{GAME_CONFIG,AI_CONFIG}from'../config/gameConfig.ts';/**\r\n * AI Engine for Pac-Man game\r\n * Implements three core AI features:\r\n * 1. Predictive Path Display - Shows ghost movement predictions\r\n * 2. Danger Zone Heatmap - Real-time danger visualization\r\n * 3. Adaptive Ghost Intelligence - Learning from player patterns\r\n */export class AIEngine{constructor(){this.playerPatterns=[];this.patternWeights={[Direction.UP]:0,[Direction.DOWN]:0,[Direction.LEFT]:0,[Direction.RIGHT]:0,[Direction.NONE]:0};this.learningLevel=0;}/**\r\n   * Analyzes current game state and provides AI insights\r\n   */analyzeGameState(pacman,ghosts,maze){const ghostPredictions=this.predictGhostMovements(ghosts,maze,pacman);const dangerLevel=this.calculateDangerLevel(pacman.position,ghosts);const suggestedDirection=this.suggestOptimalDirection(pacman,ghosts,maze);const safeZones=this.findSafeZones(pacman.position,ghosts,maze);const escapeRoutes=this.findEscapeRoutes(pacman.position,ghosts,maze);return{dangerLevel,suggestedDirection,ghostPredictions,safeZones,escapeRoutes,playerTendencies:_objectSpread({},this.patternWeights)};}/**\r\n   * Predicts ghost movements using A* pathfinding and behavior patterns\r\n   */predictGhostMovements(ghosts,maze,pacman){const predictions={[GhostType.BLINKY]:[],[GhostType.PINKY]:[],[GhostType.INKY]:[],[GhostType.CLYDE]:[]};ghosts.forEach(ghost=>{if(ghost.state===GhostState.FRIGHTENED||ghost.state===GhostState.EATEN){// Frightened ghosts move randomly, harder to predict\npredictions[ghost.id]=this.predictRandomMovement(ghost,maze);}else{// Use A* pathfinding to predict chase/scatter behavior\nconst target=this.getGhostTarget(ghost,pacman,ghosts);predictions[ghost.id]=this.predictPathToTarget(ghost,target,maze);}});return predictions;}/**\r\n   * Calculates danger level at given position based on ghost proximity and states\r\n   */calculateDangerLevel(position,ghosts){let totalDanger=0;ghosts.forEach(ghost=>{if(ghost.state===GhostState.FRIGHTENED||ghost.state===GhostState.EATEN){return;// No danger from frightened/eaten ghosts\n}const distance=this.manhattanDistance(position,ghost.position);const maxDangerDistance=AI_CONFIG.DANGER_RADIUS;if(distance<=maxDangerDistance){// Closer ghosts are more dangerous\nconst dangerContribution=(maxDangerDistance-distance)/maxDangerDistance;totalDanger+=dangerContribution;}});return Math.min(totalDanger,1);// Normalize to 0-1\n}/**\r\n   * Generates danger heatmap for the entire maze\r\n   */generateDangerHeatmap(ghosts,maze){const heatmap=Array(maze.length).fill(null).map(()=>Array(maze[0].length).fill(0));for(let y=0;y<maze.length;y++){for(let x=0;x<maze[0].length;x++){if(maze[y][x]===CellType.WALL){heatmap[y][x]=-1;// Mark walls\ncontinue;}heatmap[y][x]=this.calculateDangerLevel({x,y},ghosts);}}return heatmap;}/**\r\n   * Records player movement patterns for adaptive AI\r\n   */recordPlayerMovement(direction){this.playerPatterns.push(direction);// Keep only recent patterns\nif(this.playerPatterns.length>AI_CONFIG.PATTERN_THRESHOLD){this.playerPatterns.shift();}// Update pattern weights\nthis.updatePatternWeights();this.updateLearningLevel();}/**\r\n   * Suggests optimal direction based on danger analysis and escape routes\r\n   */suggestOptimalDirection(pacman,ghosts,maze){const possibleDirections=this.getPossibleDirections(pacman.position,maze);let bestDirection=Direction.NONE;let lowestDanger=Infinity;possibleDirections.forEach(direction=>{const nextPosition=this.getNextPosition(pacman.position,direction);const danger=this.calculateDangerLevel(nextPosition,ghosts);// Consider future danger by looking ahead\nconst futureDanger=this.calculateFutureDanger(nextPosition,ghosts,maze,3);const totalDanger=danger+futureDanger*0.5;if(totalDanger<lowestDanger){lowestDanger=totalDanger;bestDirection=direction;}});return bestDirection;}/**\r\n   * Finds safe zones where player can temporarily hide\r\n   */findSafeZones(pacmanPosition,ghosts,maze){const safeZones=[];const safeDistance=AI_CONFIG.SAFE_DISTANCE;for(let y=0;y<maze.length;y++){for(let x=0;x<maze[0].length;x++){if(maze[y][x]===CellType.WALL)continue;const position={x,y};const isSafe=ghosts.every(ghost=>{if(ghost.state===GhostState.FRIGHTENED||ghost.state===GhostState.EATEN){return true;}return this.manhattanDistance(position,ghost.position)>=safeDistance;});if(isSafe&&this.manhattanDistance(position,pacmanPosition)<=8){safeZones.push(position);}}}return safeZones;}/**\r\n   * Finds escape routes when surrounded by ghosts\r\n   */findEscapeRoutes(pacmanPosition,ghosts,maze){const escapeRoutes=[];const visited=new Set();const queue=[{position:pacmanPosition,path:[]}];while(queue.length>0){const{position,path}=queue.shift();const key=\"\".concat(position.x,\",\").concat(position.y);if(visited.has(key)||path.length>6)continue;visited.add(key);// Check if this position is safe\nconst danger=this.calculateDangerLevel(position,ghosts);if(danger<0.3&&path.length>2){escapeRoutes.push(...path);continue;}// Explore adjacent positions\nconst directions=[Direction.UP,Direction.DOWN,Direction.LEFT,Direction.RIGHT];directions.forEach(direction=>{const nextPos=this.getNextPosition(position,direction);if(this.isValidPosition(nextPos,maze)){queue.push({position:nextPos,path:[...path,nextPos]});}});}return escapeRoutes;}/**\r\n   * Adapts ghost behavior based on learned player patterns\r\n   */adaptGhostBehavior(ghost,pacman,ghosts){const baseTarget=this.getGhostTarget(ghost,pacman,ghosts);if(this.learningLevel<20){return baseTarget;// Not enough learning yet\n}// Predict where player is likely to go based on patterns\nconst predictedDirection=this.predictPlayerDirection();const predictedPosition=this.getNextPosition(pacman.position,predictedDirection);// Adjust ghost target to intercept predicted path\nconst interceptTarget=this.calculateInterceptPoint(ghost.position,predictedPosition,pacman.velocity);// Blend original target with intercept target based on learning level\nconst learningWeight=Math.min(this.learningLevel/100,0.7);return{x:Math.round(baseTarget.x*(1-learningWeight)+interceptTarget.x*learningWeight),y:Math.round(baseTarget.y*(1-learningWeight)+interceptTarget.y*learningWeight)};}// Private helper methods\npredictRandomMovement(ghost,maze){const predictions=[];let currentPos=_objectSpread({},ghost.position);for(let i=0;i<GAME_CONFIG.AI_PREDICTION_STEPS;i++){const possibleDirections=this.getPossibleDirections(currentPos,maze);const randomDirection=possibleDirections[Math.floor(Math.random()*possibleDirections.length)];currentPos=this.getNextPosition(currentPos,randomDirection);predictions.push(_objectSpread({},currentPos));}return predictions;}predictPathToTarget(ghost,target,maze){const path=this.findPathAStar(ghost.position,target,maze);return path.slice(1,GAME_CONFIG.AI_PREDICTION_STEPS+1);}findPathAStar(start,goal,maze){const openSet=[start];const cameFrom=new Map();const gScore=new Map();const fScore=new Map();gScore.set(\"\".concat(start.x,\",\").concat(start.y),0);fScore.set(\"\".concat(start.x,\",\").concat(start.y),this.manhattanDistance(start,goal));while(openSet.length>0){// Find node with lowest fScore\nlet current=openSet[0];let currentIndex=0;for(let i=1;i<openSet.length;i++){const currentKey=\"\".concat(current.x,\",\").concat(current.y);const nodeKey=\"\".concat(openSet[i].x,\",\").concat(openSet[i].y);if((fScore.get(nodeKey)||Infinity)<(fScore.get(currentKey)||Infinity)){current=openSet[i];currentIndex=i;}}if(current.x===goal.x&&current.y===goal.y){// Reconstruct path\nconst path=[current];let currentKey=\"\".concat(current.x,\",\").concat(current.y);while(cameFrom.has(currentKey)){current=cameFrom.get(currentKey);path.unshift(current);currentKey=\"\".concat(current.x,\",\").concat(current.y);}return path;}openSet.splice(currentIndex,1);// Check neighbors\nconst directions=[Direction.UP,Direction.DOWN,Direction.LEFT,Direction.RIGHT];directions.forEach(direction=>{const neighbor=this.getNextPosition(current,direction);if(!this.isValidPosition(neighbor,maze))return;const neighborKey=\"\".concat(neighbor.x,\",\").concat(neighbor.y);const tentativeGScore=(gScore.get(\"\".concat(current.x,\",\").concat(current.y))||0)+1;if(tentativeGScore<(gScore.get(neighborKey)||Infinity)){cameFrom.set(neighborKey,current);gScore.set(neighborKey,tentativeGScore);fScore.set(neighborKey,tentativeGScore+this.manhattanDistance(neighbor,goal));if(!openSet.some(pos=>pos.x===neighbor.x&&pos.y===neighbor.y)){openSet.push(neighbor);}}});}return[];// No path found\n}getGhostTarget(ghost,pacman,ghosts){switch(ghost.id){case GhostType.BLINKY:// Blinky targets Pac-Man directly\nreturn pacman.position;case GhostType.PINKY:// Pinky targets 4 cells ahead of Pac-Man\nreturn this.getPositionAhead(pacman.position,pacman.direction,4);case GhostType.INKY:// Inky uses complex targeting involving Blinky\nconst blinky=ghosts.find(g=>g.id===GhostType.BLINKY);if(blinky){const ahead=this.getPositionAhead(pacman.position,pacman.direction,2);return{x:ahead.x+(ahead.x-blinky.position.x),y:ahead.y+(ahead.y-blinky.position.y)};}return pacman.position;case GhostType.CLYDE:// Clyde targets Pac-Man when far, scatters when close\nconst distance=this.manhattanDistance(ghost.position,pacman.position);return distance>8?pacman.position:ghost.scatterTarget;default:return pacman.position;}}updatePatternWeights(){// Reset weights\nObject.keys(this.patternWeights).forEach(key=>{this.patternWeights[key]=0;});// Calculate frequency of each direction\nthis.playerPatterns.forEach(direction=>{this.patternWeights[direction]++;});// Normalize to percentages\nconst total=this.playerPatterns.length;Object.keys(this.patternWeights).forEach(key=>{this.patternWeights[key]/=total;});}updateLearningLevel(){// Learning level increases with pattern consistency\nconst maxWeight=Math.max(...Object.values(this.patternWeights));const consistency=maxWeight-0.25;// 0.25 is random chance\nif(consistency>0){this.learningLevel=Math.min(this.learningLevel+consistency*AI_CONFIG.LEARNING_RATE,AI_CONFIG.MAX_LEARNING_LEVEL);}}predictPlayerDirection(){const weights=this.patternWeights;let maxWeight=0;let predictedDirection=Direction.NONE;Object.entries(weights).forEach(_ref=>{let[direction,weight]=_ref;if(weight>maxWeight){maxWeight=weight;predictedDirection=direction;}});return predictedDirection;}calculateInterceptPoint(ghostPos,targetPos,targetVelocity){// Simple interception calculation\nconst dx=targetPos.x-ghostPos.x;const dy=targetPos.y-ghostPos.y;const distance=Math.sqrt(dx*dx+dy*dy);const timeToReach=distance/GAME_CONFIG.GHOST_SPEED;return{x:Math.round(targetPos.x+targetVelocity.dx*timeToReach),y:Math.round(targetPos.y+targetVelocity.dy*timeToReach)};}calculateFutureDanger(position,ghosts,maze,steps){let totalDanger=0;for(let step=1;step<=steps;step++){const currentStep=step;// Capture step value to avoid closure issue\n// eslint-disable-next-line no-loop-func\nghosts.forEach(ghost=>{if(ghost.state===GhostState.FRIGHTENED||ghost.state===GhostState.EATEN){return;}// Estimate ghost position after 'step' moves\nconst futureGhostPos=this.estimateGhostPosition(ghost,currentStep);const distance=this.manhattanDistance(position,futureGhostPos);if(distance<=AI_CONFIG.DANGER_RADIUS){totalDanger+=(AI_CONFIG.DANGER_RADIUS-distance)/AI_CONFIG.DANGER_RADIUS/currentStep;}});}return totalDanger;}estimateGhostPosition(ghost,steps){// Simple estimation - ghost moves toward its current target\nconst dx=ghost.targetPosition.x-ghost.position.x;const dy=ghost.targetPosition.y-ghost.position.y;const distance=Math.sqrt(dx*dx+dy*dy);if(distance===0)return ghost.position;const normalizedDx=dx/distance;const normalizedDy=dy/distance;return{x:Math.round(ghost.position.x+normalizedDx*GAME_CONFIG.GHOST_SPEED*steps),y:Math.round(ghost.position.y+normalizedDy*GAME_CONFIG.GHOST_SPEED*steps)};}getPossibleDirections(position,maze){const directions=[];if(this.isValidPosition(this.getNextPosition(position,Direction.UP),maze)){directions.push(Direction.UP);}if(this.isValidPosition(this.getNextPosition(position,Direction.DOWN),maze)){directions.push(Direction.DOWN);}if(this.isValidPosition(this.getNextPosition(position,Direction.LEFT),maze)){directions.push(Direction.LEFT);}if(this.isValidPosition(this.getNextPosition(position,Direction.RIGHT),maze)){directions.push(Direction.RIGHT);}return directions;}getNextPosition(position,direction){switch(direction){case Direction.UP:return{x:position.x,y:position.y-1};case Direction.DOWN:return{x:position.x,y:position.y+1};case Direction.LEFT:return{x:position.x-1,y:position.y};case Direction.RIGHT:return{x:position.x+1,y:position.y};default:return position;}}getPositionAhead(position,direction,distance){switch(direction){case Direction.UP:return{x:position.x,y:position.y-distance};case Direction.DOWN:return{x:position.x,y:position.y+distance};case Direction.LEFT:return{x:position.x-distance,y:position.y};case Direction.RIGHT:return{x:position.x+distance,y:position.y};default:return position;}}isValidPosition(position,maze){if(position.y<0||position.y>=maze.length)return false;if(position.x<0||position.x>=maze[0].length)return false;return maze[position.y][position.x]!==CellType.WALL;}manhattanDistance(pos1,pos2){return Math.abs(pos1.x-pos2.x)+Math.abs(pos1.y-pos2.y);}// Getters for external access\ngetLearningLevel(){return this.learningLevel;}getPlayerPatterns(){return[...this.playerPatterns];}getPatternWeights(){return _objectSpread({},this.patternWeights);}}","map":{"version":3,"names":["Direction","CellType","GhostState","GhostType","GAME_CONFIG","AI_CONFIG","AIEngine","constructor","playerPatterns","patternWeights","UP","DOWN","LEFT","RIGHT","NONE","learningLevel","analyzeGameState","pacman","ghosts","maze","ghostPredictions","predictGhostMovements","dangerLevel","calculateDangerLevel","position","suggestedDirection","suggestOptimalDirection","safeZones","findSafeZones","escapeRoutes","findEscapeRoutes","playerTendencies","_objectSpread","predictions","BLINKY","PINKY","INKY","CLYDE","forEach","ghost","state","FRIGHTENED","EATEN","id","predictRandomMovement","target","getGhostTarget","predictPathToTarget","totalDanger","distance","manhattanDistance","maxDangerDistance","DANGER_RADIUS","dangerContribution","Math","min","generateDangerHeatmap","heatmap","Array","length","fill","map","y","x","WALL","recordPlayerMovement","direction","push","PATTERN_THRESHOLD","shift","updatePatternWeights","updateLearningLevel","possibleDirections","getPossibleDirections","bestDirection","lowestDanger","Infinity","nextPosition","getNextPosition","danger","futureDanger","calculateFutureDanger","pacmanPosition","safeDistance","SAFE_DISTANCE","isSafe","every","visited","Set","queue","path","key","concat","has","add","directions","nextPos","isValidPosition","adaptGhostBehavior","baseTarget","predictedDirection","predictPlayerDirection","predictedPosition","interceptTarget","calculateInterceptPoint","velocity","learningWeight","round","currentPos","i","AI_PREDICTION_STEPS","randomDirection","floor","random","findPathAStar","slice","start","goal","openSet","cameFrom","Map","gScore","fScore","set","current","currentIndex","currentKey","nodeKey","get","unshift","splice","neighbor","neighborKey","tentativeGScore","some","pos","getPositionAhead","blinky","find","g","ahead","scatterTarget","Object","keys","total","maxWeight","max","values","consistency","LEARNING_RATE","MAX_LEARNING_LEVEL","weights","entries","_ref","weight","ghostPos","targetPos","targetVelocity","dx","dy","sqrt","timeToReach","GHOST_SPEED","steps","step","currentStep","futureGhostPos","estimateGhostPosition","targetPosition","normalizedDx","normalizedDy","pos1","pos2","abs","getLearningLevel","getPlayerPatterns","getPatternWeights"],"sources":["C:/Users/VEDANT/Desktop/Src/Pacman/src/engine/AIEngine.ts"],"sourcesContent":["import { \r\n  Position, \r\n  Direction, \r\n  Ghost, \r\n  PacMan, \r\n  CellType, \r\n  GhostState,\r\n  AIAnalysis,\r\n  GhostType \r\n} from '../types/game.ts';\r\nimport { GAME_CONFIG, AI_CONFIG } from '../config/gameConfig.ts';\r\n\r\n/**\r\n * AI Engine for Pac-Man game\r\n * Implements three core AI features:\r\n * 1. Predictive Path Display - Shows ghost movement predictions\r\n * 2. Danger Zone Heatmap - Real-time danger visualization\r\n * 3. Adaptive Ghost Intelligence - Learning from player patterns\r\n */\r\nexport class AIEngine {\r\n  private playerPatterns: Direction[] = [];\r\n  private patternWeights: { [key in Direction]: number } = {\r\n    [Direction.UP]: 0,\r\n    [Direction.DOWN]: 0,\r\n    [Direction.LEFT]: 0,\r\n    [Direction.RIGHT]: 0,\r\n    [Direction.NONE]: 0\r\n  };\r\n  private learningLevel: number = 0;\r\n\r\n  /**\r\n   * Analyzes current game state and provides AI insights\r\n   */\r\n  analyzeGameState(\r\n    pacman: PacMan,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): AIAnalysis {\r\n    const ghostPredictions = this.predictGhostMovements(ghosts, maze, pacman);\r\n    const dangerLevel = this.calculateDangerLevel(pacman.position, ghosts);\r\n    const suggestedDirection = this.suggestOptimalDirection(pacman, ghosts, maze);\r\n    const safeZones = this.findSafeZones(pacman.position, ghosts, maze);\r\n    const escapeRoutes = this.findEscapeRoutes(pacman.position, ghosts, maze);\r\n\r\n    return {\r\n      dangerLevel,\r\n      suggestedDirection,\r\n      ghostPredictions,\r\n      safeZones,\r\n      escapeRoutes,\r\n      playerTendencies: { ...this.patternWeights }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Predicts ghost movements using A* pathfinding and behavior patterns\r\n   */\r\n  predictGhostMovements(\r\n    ghosts: Ghost[],\r\n    maze: CellType[][],\r\n    pacman: PacMan\r\n  ): { [key in GhostType]: Position[] } {\r\n    const predictions: { [key in GhostType]: Position[] } = {\r\n      [GhostType.BLINKY]: [],\r\n      [GhostType.PINKY]: [],\r\n      [GhostType.INKY]: [],\r\n      [GhostType.CLYDE]: []\r\n    };\r\n\r\n    ghosts.forEach(ghost => {\r\n      if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n        // Frightened ghosts move randomly, harder to predict\r\n        predictions[ghost.id] = this.predictRandomMovement(ghost, maze);\r\n      } else {\r\n        // Use A* pathfinding to predict chase/scatter behavior\r\n        const target = this.getGhostTarget(ghost, pacman, ghosts);\r\n        predictions[ghost.id] = this.predictPathToTarget(ghost, target, maze);\r\n      }\r\n    });\r\n\r\n    return predictions;\r\n  }\r\n\r\n  /**\r\n   * Calculates danger level at given position based on ghost proximity and states\r\n   */\r\n  calculateDangerLevel(position: Position, ghosts: Ghost[]): number {\r\n    let totalDanger = 0;\r\n\r\n    ghosts.forEach(ghost => {\r\n      if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n        return; // No danger from frightened/eaten ghosts\r\n      }\r\n\r\n      const distance = this.manhattanDistance(position, ghost.position);\r\n      const maxDangerDistance = AI_CONFIG.DANGER_RADIUS;\r\n\r\n      if (distance <= maxDangerDistance) {\r\n        // Closer ghosts are more dangerous\r\n        const dangerContribution = (maxDangerDistance - distance) / maxDangerDistance;\r\n        totalDanger += dangerContribution;\r\n      }\r\n    });\r\n\r\n    return Math.min(totalDanger, 1); // Normalize to 0-1\r\n  }\r\n\r\n  /**\r\n   * Generates danger heatmap for the entire maze\r\n   */\r\n  generateDangerHeatmap(ghosts: Ghost[], maze: CellType[][]): number[][] {\r\n    const heatmap: number[][] = Array(maze.length).fill(null)\r\n      .map(() => Array(maze[0].length).fill(0));\r\n\r\n    for (let y = 0; y < maze.length; y++) {\r\n      for (let x = 0; x < maze[0].length; x++) {\r\n        if (maze[y][x] === CellType.WALL) {\r\n          heatmap[y][x] = -1; // Mark walls\r\n          continue;\r\n        }\r\n\r\n        heatmap[y][x] = this.calculateDangerLevel({ x, y }, ghosts);\r\n      }\r\n    }\r\n\r\n    return heatmap;\r\n  }\r\n\r\n  /**\r\n   * Records player movement patterns for adaptive AI\r\n   */\r\n  recordPlayerMovement(direction: Direction): void {\r\n    this.playerPatterns.push(direction);\r\n\r\n    // Keep only recent patterns\r\n    if (this.playerPatterns.length > AI_CONFIG.PATTERN_THRESHOLD) {\r\n      this.playerPatterns.shift();\r\n    }\r\n\r\n    // Update pattern weights\r\n    this.updatePatternWeights();\r\n    this.updateLearningLevel();\r\n  }\r\n\r\n  /**\r\n   * Suggests optimal direction based on danger analysis and escape routes\r\n   */\r\n  suggestOptimalDirection(\r\n    pacman: PacMan,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): Direction {\r\n    const possibleDirections = this.getPossibleDirections(pacman.position, maze);\r\n    let bestDirection = Direction.NONE;\r\n    let lowestDanger = Infinity;\r\n\r\n    possibleDirections.forEach(direction => {\r\n      const nextPosition = this.getNextPosition(pacman.position, direction);\r\n      const danger = this.calculateDangerLevel(nextPosition, ghosts);\r\n      \r\n      // Consider future danger by looking ahead\r\n      const futureDanger = this.calculateFutureDanger(nextPosition, ghosts, maze, 3);\r\n      const totalDanger = danger + (futureDanger * 0.5);\r\n\r\n      if (totalDanger < lowestDanger) {\r\n        lowestDanger = totalDanger;\r\n        bestDirection = direction;\r\n      }\r\n    });\r\n\r\n    return bestDirection;\r\n  }\r\n\r\n  /**\r\n   * Finds safe zones where player can temporarily hide\r\n   */\r\n  findSafeZones(\r\n    pacmanPosition: Position,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const safeZones: Position[] = [];\r\n    const safeDistance = AI_CONFIG.SAFE_DISTANCE;\r\n\r\n    for (let y = 0; y < maze.length; y++) {\r\n      for (let x = 0; x < maze[0].length; x++) {\r\n        if (maze[y][x] === CellType.WALL) continue;\r\n\r\n        const position = { x, y };\r\n        const isSafe = ghosts.every(ghost => {\r\n          if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n            return true;\r\n          }\r\n          return this.manhattanDistance(position, ghost.position) >= safeDistance;\r\n        });\r\n\r\n        if (isSafe && this.manhattanDistance(position, pacmanPosition) <= 8) {\r\n          safeZones.push(position);\r\n        }\r\n      }\r\n    }\r\n\r\n    return safeZones;\r\n  }\r\n\r\n  /**\r\n   * Finds escape routes when surrounded by ghosts\r\n   */\r\n  findEscapeRoutes(\r\n    pacmanPosition: Position,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const escapeRoutes: Position[] = [];\r\n    const visited = new Set<string>();\r\n    const queue: { position: Position; path: Position[] }[] = [\r\n      { position: pacmanPosition, path: [] }\r\n    ];\r\n\r\n    while (queue.length > 0) {\r\n      const { position, path } = queue.shift()!;\r\n      const key = `${position.x},${position.y}`;\r\n\r\n      if (visited.has(key) || path.length > 6) continue;\r\n      visited.add(key);\r\n\r\n      // Check if this position is safe\r\n      const danger = this.calculateDangerLevel(position, ghosts);\r\n      if (danger < 0.3 && path.length > 2) {\r\n        escapeRoutes.push(...path);\r\n        continue;\r\n      }\r\n\r\n      // Explore adjacent positions\r\n      const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];\r\n      directions.forEach(direction => {\r\n        const nextPos = this.getNextPosition(position, direction);\r\n        if (this.isValidPosition(nextPos, maze)) {\r\n          queue.push({\r\n            position: nextPos,\r\n            path: [...path, nextPos]\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return escapeRoutes;\r\n  }\r\n\r\n  /**\r\n   * Adapts ghost behavior based on learned player patterns\r\n   */\r\n  adaptGhostBehavior(ghost: Ghost, pacman: PacMan, ghosts: Ghost[]): Position {\r\n    const baseTarget = this.getGhostTarget(ghost, pacman, ghosts);\r\n    \r\n    if (this.learningLevel < 20) {\r\n      return baseTarget; // Not enough learning yet\r\n    }\r\n\r\n    // Predict where player is likely to go based on patterns\r\n    const predictedDirection = this.predictPlayerDirection();\r\n    const predictedPosition = this.getNextPosition(pacman.position, predictedDirection);\r\n\r\n    // Adjust ghost target to intercept predicted path\r\n    const interceptTarget = this.calculateInterceptPoint(\r\n      ghost.position,\r\n      predictedPosition,\r\n      pacman.velocity\r\n    );\r\n\r\n    // Blend original target with intercept target based on learning level\r\n    const learningWeight = Math.min(this.learningLevel / 100, 0.7);\r\n    \r\n    return {\r\n      x: Math.round(baseTarget.x * (1 - learningWeight) + interceptTarget.x * learningWeight),\r\n      y: Math.round(baseTarget.y * (1 - learningWeight) + interceptTarget.y * learningWeight)\r\n    };\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private predictRandomMovement(ghost: Ghost, maze: CellType[][]): Position[] {\r\n    const predictions: Position[] = [];\r\n    let currentPos = { ...ghost.position };\r\n\r\n    for (let i = 0; i < GAME_CONFIG.AI_PREDICTION_STEPS; i++) {\r\n      const possibleDirections = this.getPossibleDirections(currentPos, maze);\r\n      const randomDirection = possibleDirections[\r\n        Math.floor(Math.random() * possibleDirections.length)\r\n      ];\r\n      currentPos = this.getNextPosition(currentPos, randomDirection);\r\n      predictions.push({ ...currentPos });\r\n    }\r\n\r\n    return predictions;\r\n  }\r\n\r\n  private predictPathToTarget(\r\n    ghost: Ghost,\r\n    target: Position,\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const path = this.findPathAStar(ghost.position, target, maze);\r\n    return path.slice(1, GAME_CONFIG.AI_PREDICTION_STEPS + 1);\r\n  }\r\n\r\n  private findPathAStar(\r\n    start: Position,\r\n    goal: Position,\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const openSet = [start];\r\n    const cameFrom = new Map<string, Position>();\r\n    const gScore = new Map<string, number>();\r\n    const fScore = new Map<string, number>();\r\n\r\n    gScore.set(`${start.x},${start.y}`, 0);\r\n    fScore.set(`${start.x},${start.y}`, this.manhattanDistance(start, goal));\r\n\r\n    while (openSet.length > 0) {\r\n      // Find node with lowest fScore\r\n      let current = openSet[0];\r\n      let currentIndex = 0;\r\n      \r\n      for (let i = 1; i < openSet.length; i++) {\r\n        const currentKey = `${current.x},${current.y}`;\r\n        const nodeKey = `${openSet[i].x},${openSet[i].y}`;\r\n        if ((fScore.get(nodeKey) || Infinity) < (fScore.get(currentKey) || Infinity)) {\r\n          current = openSet[i];\r\n          currentIndex = i;\r\n        }\r\n      }\r\n\r\n      if (current.x === goal.x && current.y === goal.y) {\r\n        // Reconstruct path\r\n        const path = [current];\r\n        let currentKey = `${current.x},${current.y}`;\r\n        \r\n        while (cameFrom.has(currentKey)) {\r\n          current = cameFrom.get(currentKey)!;\r\n          path.unshift(current);\r\n          currentKey = `${current.x},${current.y}`;\r\n        }\r\n        \r\n        return path;\r\n      }\r\n\r\n      openSet.splice(currentIndex, 1);\r\n      \r\n      // Check neighbors\r\n      const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];\r\n      directions.forEach(direction => {\r\n        const neighbor = this.getNextPosition(current, direction);\r\n        \r\n        if (!this.isValidPosition(neighbor, maze)) return;\r\n\r\n        const neighborKey = `${neighbor.x},${neighbor.y}`;\r\n        const tentativeGScore = (gScore.get(`${current.x},${current.y}`) || 0) + 1;\r\n\r\n        if (tentativeGScore < (gScore.get(neighborKey) || Infinity)) {\r\n          cameFrom.set(neighborKey, current);\r\n          gScore.set(neighborKey, tentativeGScore);\r\n          fScore.set(neighborKey, tentativeGScore + this.manhattanDistance(neighbor, goal));\r\n\r\n          if (!openSet.some(pos => pos.x === neighbor.x && pos.y === neighbor.y)) {\r\n            openSet.push(neighbor);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    return []; // No path found\r\n  }\r\n\r\n  private getGhostTarget(ghost: Ghost, pacman: PacMan, ghosts: Ghost[]): Position {\r\n    switch (ghost.id) {\r\n      case GhostType.BLINKY:\r\n        // Blinky targets Pac-Man directly\r\n        return pacman.position;\r\n        \r\n      case GhostType.PINKY:\r\n        // Pinky targets 4 cells ahead of Pac-Man\r\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\r\n        \r\n      case GhostType.INKY:\r\n        // Inky uses complex targeting involving Blinky\r\n        const blinky = ghosts.find(g => g.id === GhostType.BLINKY);\r\n        if (blinky) {\r\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\r\n          return {\r\n            x: ahead.x + (ahead.x - blinky.position.x),\r\n            y: ahead.y + (ahead.y - blinky.position.y)\r\n          };\r\n        }\r\n        return pacman.position;\r\n        \r\n      case GhostType.CLYDE:\r\n        // Clyde targets Pac-Man when far, scatters when close\r\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\r\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\r\n        \r\n      default:\r\n        return pacman.position;\r\n    }\r\n  }\r\n\r\n  private updatePatternWeights(): void {\r\n    // Reset weights\r\n    Object.keys(this.patternWeights).forEach(key => {\r\n      this.patternWeights[key as Direction] = 0;\r\n    });\r\n\r\n    // Calculate frequency of each direction\r\n    this.playerPatterns.forEach(direction => {\r\n      this.patternWeights[direction]++;\r\n    });\r\n\r\n    // Normalize to percentages\r\n    const total = this.playerPatterns.length;\r\n    Object.keys(this.patternWeights).forEach(key => {\r\n      this.patternWeights[key as Direction] /= total;\r\n    });\r\n  }\r\n\r\n  private updateLearningLevel(): void {\r\n    // Learning level increases with pattern consistency\r\n    const maxWeight = Math.max(...Object.values(this.patternWeights));\r\n    const consistency = maxWeight - 0.25; // 0.25 is random chance\r\n    \r\n    if (consistency > 0) {\r\n      this.learningLevel = Math.min(\r\n        this.learningLevel + (consistency * AI_CONFIG.LEARNING_RATE),\r\n        AI_CONFIG.MAX_LEARNING_LEVEL\r\n      );\r\n    }\r\n  }\r\n\r\n  private predictPlayerDirection(): Direction {\r\n    const weights = this.patternWeights;\r\n    let maxWeight = 0;\r\n    let predictedDirection = Direction.NONE;\r\n\r\n    Object.entries(weights).forEach(([direction, weight]) => {\r\n      if (weight > maxWeight) {\r\n        maxWeight = weight;\r\n        predictedDirection = direction as Direction;\r\n      }\r\n    });\r\n\r\n    return predictedDirection;\r\n  }\r\n\r\n  private calculateInterceptPoint(\r\n    ghostPos: Position,\r\n    targetPos: Position,\r\n    targetVelocity: { dx: number; dy: number }\r\n  ): Position {\r\n    // Simple interception calculation\r\n    const dx = targetPos.x - ghostPos.x;\r\n    const dy = targetPos.y - ghostPos.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    const timeToReach = distance / GAME_CONFIG.GHOST_SPEED;\r\n\r\n    return {\r\n      x: Math.round(targetPos.x + targetVelocity.dx * timeToReach),\r\n      y: Math.round(targetPos.y + targetVelocity.dy * timeToReach)\r\n    };\r\n  }\r\n\r\n  private calculateFutureDanger(\r\n    position: Position,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][],\r\n    steps: number\r\n  ): number {\r\n    let totalDanger = 0;\r\n\r\n    for (let step = 1; step <= steps; step++) {\r\n      const currentStep = step; // Capture step value to avoid closure issue\r\n      // eslint-disable-next-line no-loop-func\r\n      ghosts.forEach(ghost => {\r\n        if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n          return;\r\n        }\r\n\r\n        // Estimate ghost position after 'step' moves\r\n        const futureGhostPos = this.estimateGhostPosition(ghost, currentStep);\r\n        const distance = this.manhattanDistance(position, futureGhostPos);\r\n        \r\n        if (distance <= AI_CONFIG.DANGER_RADIUS) {\r\n          totalDanger += (AI_CONFIG.DANGER_RADIUS - distance) / AI_CONFIG.DANGER_RADIUS / currentStep;\r\n        }\r\n      });\r\n    }\r\n\r\n    return totalDanger;\r\n  }\r\n\r\n  private estimateGhostPosition(ghost: Ghost, steps: number): Position {\r\n    // Simple estimation - ghost moves toward its current target\r\n    const dx = ghost.targetPosition.x - ghost.position.x;\r\n    const dy = ghost.targetPosition.y - ghost.position.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    if (distance === 0) return ghost.position;\r\n\r\n    const normalizedDx = dx / distance;\r\n    const normalizedDy = dy / distance;\r\n\r\n    return {\r\n      x: Math.round(ghost.position.x + normalizedDx * GAME_CONFIG.GHOST_SPEED * steps),\r\n      y: Math.round(ghost.position.y + normalizedDy * GAME_CONFIG.GHOST_SPEED * steps)\r\n    };\r\n  }\r\n\r\n  private getPossibleDirections(position: Position, maze: CellType[][]): Direction[] {\r\n    const directions: Direction[] = [];\r\n    \r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.UP), maze)) {\r\n      directions.push(Direction.UP);\r\n    }\r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.DOWN), maze)) {\r\n      directions.push(Direction.DOWN);\r\n    }\r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.LEFT), maze)) {\r\n      directions.push(Direction.LEFT);\r\n    }\r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.RIGHT), maze)) {\r\n      directions.push(Direction.RIGHT);\r\n    }\r\n\r\n    return directions;\r\n  }\r\n\r\n  private getNextPosition(position: Position, direction: Direction): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - 1 };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + 1 };\r\n      case Direction.LEFT:\r\n        return { x: position.x - 1, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + 1, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getPositionAhead(position: Position, direction: Direction, distance: number): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - distance };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + distance };\r\n      case Direction.LEFT:\r\n        return { x: position.x - distance, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + distance, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private isValidPosition(position: Position, maze: CellType[][]): boolean {\r\n    if (position.y < 0 || position.y >= maze.length) return false;\r\n    if (position.x < 0 || position.x >= maze[0].length) return false;\r\n    return maze[position.y][position.x] !== CellType.WALL;\r\n  }\r\n\r\n  private manhattanDistance(pos1: Position, pos2: Position): number {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n  }\r\n\r\n  // Getters for external access\r\n  getLearningLevel(): number {\r\n    return this.learningLevel;\r\n  }\r\n\r\n  getPlayerPatterns(): Direction[] {\r\n    return [...this.playerPatterns];\r\n  }\r\n\r\n  getPatternWeights(): { [key in Direction]: number } {\r\n    return { ...this.patternWeights };\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}