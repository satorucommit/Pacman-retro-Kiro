{"ast":null,"code":"import { Direction, CellType, GhostState, GhostType } from '../types/game.ts';\nimport { GAME_CONFIG, MAZE_LAYOUT, GHOST_CONFIG, PACMAN_START_POSITION } from '../config/gameConfig.ts';\nimport { AIEngine } from './AIEngine.ts';\n\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\nexport class GameEngine {\n  constructor() {\n    this.aiEngine = void 0;\n    this.gameState = void 0;\n    this.lastUpdateTime = 0;\n    this.frameCount = 0;\n    this.difficultyMultiplier = 1.0;\n    this.aiEngine = new AIEngine();\n    this.gameState = this.initializeGameState();\n  }\n\n  /**\r\n   * Initialize the game state with default values\r\n   */\n  initializeGameState() {\n    const maze = MAZE_LAYOUT.map(row => [...row]);\n    const pelletsRemaining = this.countPellets(maze);\n    return {\n      pacman: this.createPacMan(),\n      ghosts: this.createGhosts(),\n      maze,\n      score: 0,\n      highScore: parseInt(localStorage.getItem('pacman_highscore') || '0'),\n      lives: 3,\n      level: 1,\n      pelletsRemaining,\n      powerPelletActive: false,\n      powerPelletTimer: 0,\n      gameStatus: 'READY',\n      ghostEatenCount: 0,\n      fruitSpawned: false,\n      fruitPosition: null,\n      fruitScore: 0,\n      aiLearningLevel: 0,\n      showAIFeatures: true,\n      dangerMap: [],\n      playerPatterns: [],\n      screenShake: false,\n      vhsGlitch: false\n    };\n  }\n\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\n  createPacMan() {\n    return {\n      position: {\n        x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE,\n        y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE\n      },\n      velocity: {\n        dx: 0,\n        dy: 0\n      },\n      direction: Direction.NONE,\n      nextDirection: Direction.NONE,\n      animationFrame: 0,\n      isDead: false,\n      mouthOpen: true\n    };\n  }\n\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\n  createGhosts() {\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\n      id: type,\n      position: {\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE,\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE\n      },\n      velocity: {\n        dx: 0,\n        dy: 0\n      },\n      direction: Direction.UP,\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\n      color: config.color,\n      targetPosition: {\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE,\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE\n      },\n      scatterTarget: {\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE,\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE\n      },\n      houseTimer: type === 'BLINKY' ? 0 : 60 + Object.keys(GHOST_CONFIG).indexOf(type) * 30,\n      frightenedTimer: 0,\n      isFlashing: false,\n      lastDirection: Direction.UP,\n      pathPrediction: []\n    }));\n  }\n\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\n  update(currentTime, inputDirection) {\n    // const deltaTime = currentTime - this.lastUpdateTime;\n    this.lastUpdateTime = currentTime;\n    this.frameCount++;\n    if (this.gameState.gameStatus !== 'PLAYING') {\n      return this.gameState;\n    }\n\n    // Update Pac-Man\n    this.updatePacMan(inputDirection);\n\n    // Update ghosts\n    this.updateGhosts();\n\n    // Check collisions\n    this.checkCollisions();\n\n    // Update power pellet timer\n    this.updatePowerPelletTimer();\n\n    // Update AI analysis\n    this.updateAIAnalysis();\n\n    // Check win/lose conditions\n    this.checkGameConditions();\n\n    // Update visual effects\n    this.updateVisualEffects();\n\n    // Spawn fruit occasionally\n    this.updateFruitSpawning();\n    return this.gameState;\n  }\n\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\n  updatePacMan(inputDirection) {\n    const pacman = this.gameState.pacman;\n\n    // Handle direction changes\n    if (inputDirection !== Direction.NONE) {\n      pacman.nextDirection = inputDirection;\n\n      // Record movement for AI learning\n      this.aiEngine.recordPlayerMovement(inputDirection);\n    }\n\n    // Try to change direction if possible\n    if (pacman.nextDirection !== pacman.direction && pacman.nextDirection !== Direction.NONE) {\n      const gridX = Math.round(pacman.position.x / GAME_CONFIG.CELL_SIZE);\n      const gridY = Math.round(pacman.position.y / GAME_CONFIG.CELL_SIZE);\n      const nextGridPos = this.getNextPosition({\n        x: gridX,\n        y: gridY\n      }, pacman.nextDirection);\n      if (this.isValidMove(nextGridPos)) {\n        pacman.direction = pacman.nextDirection;\n        this.setVelocity(pacman, pacman.direction);\n      }\n    }\n\n    // Move Pac-Man\n    if (pacman.direction !== Direction.NONE) {\n      let nextX = pacman.position.x + pacman.velocity.dx;\n      let nextY = pacman.position.y + pacman.velocity.dy;\n\n      // Handle tunnel wraparound\n      if (nextX < 0) {\n        nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\n      } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\n        nextX = 0;\n      }\n\n      // Check if move is valid by converting to grid coordinates\n      const gridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\n      const gridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\n      if (this.isValidMove({\n        x: gridX,\n        y: gridY\n      })) {\n        pacman.position.x = nextX;\n        pacman.position.y = nextY;\n      } else {\n        // Stop if hitting wall\n        pacman.direction = Direction.NONE;\n        pacman.velocity = {\n          dx: 0,\n          dy: 0\n        };\n      }\n    }\n\n    // Update animation\n    if (this.frameCount % 8 === 0) {\n      pacman.mouthOpen = !pacman.mouthOpen;\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\n    }\n  }\n\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\n  updateGhosts() {\n    this.gameState.ghosts.forEach(ghost => {\n      this.updateGhostState(ghost);\n      this.updateGhostMovement(ghost);\n      this.updateGhostAnimation(ghost);\n    });\n  }\n\n  /**\r\n   * Update individual ghost state and target\r\n   */\n  updateGhostState(ghost) {\n    // Handle house timer\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\n      ghost.houseTimer--;\n      if (ghost.houseTimer <= 0) {\n        ghost.state = GhostState.CHASE;\n      }\n      return;\n    }\n\n    // Handle frightened state\n    if (ghost.state === GhostState.FRIGHTENED) {\n      ghost.frightenedTimer--;\n\n      // Start flashing when timer is low\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\n      }\n      if (ghost.frightenedTimer <= 0) {\n        ghost.state = GhostState.CHASE;\n        ghost.isFlashing = false;\n      }\n      return;\n    }\n\n    // Handle eaten state\n    if (ghost.state === GhostState.EATEN) {\n      // Return to house\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\n        ghost.state = GhostState.CHASE;\n      }\n      ghost.targetPosition = housePos;\n      return;\n    }\n\n    // Normal chase/scatter behavior with AI adaptation\n    // const baseTarget = this.getGhostTarget(ghost);\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(ghost, this.gameState.pacman, this.gameState.ghosts);\n\n    // Alternate between chase and scatter modes\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\n  }\n\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\n  updateGhostMovement(ghost) {\n    if (ghost.state === GhostState.IN_HOUSE) {\n      // Simple up-down movement in house\n      if (this.frameCount % 60 < 30) {\n        ghost.direction = Direction.UP;\n      } else {\n        ghost.direction = Direction.DOWN;\n      }\n      this.setGhostVelocity(ghost);\n      return;\n    }\n\n    // Convert ghost position to grid coordinates for pathfinding\n    const gridX = Math.round(ghost.position.x / GAME_CONFIG.CELL_SIZE);\n    const gridY = Math.round(ghost.position.y / GAME_CONFIG.CELL_SIZE);\n    const gridPos = {\n      x: gridX,\n      y: gridY\n    };\n\n    // Get possible directions (can't reverse unless frightened)\n    const possibleDirections = this.getPossibleDirections(gridPos).filter(dir => {\n      if (ghost.state === GhostState.FRIGHTENED) return true;\n      return this.getOppositeDirection(dir) !== ghost.lastDirection;\n    });\n    if (possibleDirections.length === 0) return;\n\n    // Choose direction based on target\n    let bestDirection = possibleDirections[0];\n    let shortestDistance = Infinity;\n    if (ghost.state === GhostState.FRIGHTENED) {\n      // Random movement when frightened\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n    } else {\n      // Move toward target\n      const targetGridX = Math.round(ghost.targetPosition.x / GAME_CONFIG.CELL_SIZE);\n      const targetGridY = Math.round(ghost.targetPosition.y / GAME_CONFIG.CELL_SIZE);\n      possibleDirections.forEach(direction => {\n        const nextPos = this.getNextPosition(gridPos, direction);\n        const distance = this.manhattanDistance(nextPos, {\n          x: targetGridX,\n          y: targetGridY\n        });\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          bestDirection = direction;\n        }\n      });\n    }\n    ghost.lastDirection = ghost.direction;\n    ghost.direction = bestDirection;\n    this.setGhostVelocity(ghost);\n\n    // Move ghost\n    let nextX = ghost.position.x + ghost.velocity.dx;\n    let nextY = ghost.position.y + ghost.velocity.dy;\n\n    // Handle tunnel wraparound\n    if (nextX < 0) {\n      nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\n    } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\n      nextX = 0;\n    }\n\n    // Check if move is valid by converting to grid coordinates\n    const nextGridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\n    const nextGridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\n    if (this.isValidMove({\n      x: nextGridX,\n      y: nextGridY\n    })) {\n      ghost.position.x = nextX;\n      ghost.position.y = nextY;\n    }\n  }\n\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\n  updateGhostAnimation(ghost) {\n    // Update path prediction for AI visualization\n    if (this.frameCount % 30 === 0) {\n      // Update every half second\n      const predictions = this.aiEngine.predictGhostMovements([ghost], this.gameState.maze, this.gameState.pacman);\n      ghost.pathPrediction = predictions[ghost.id] || [];\n    }\n  }\n\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\n  checkCollisions() {\n    const pacmanPos = this.gameState.pacman.position;\n    const gridX = Math.round(pacmanPos.x / GAME_CONFIG.CELL_SIZE);\n    const gridY = Math.round(pacmanPos.y / GAME_CONFIG.CELL_SIZE);\n\n    // Ensure we're within bounds\n    if (gridX < 0 || gridX >= GAME_CONFIG.MAZE_WIDTH || gridY < 0 || gridY >= GAME_CONFIG.MAZE_HEIGHT) {\n      return;\n    }\n    const cellType = this.gameState.maze[gridY][gridX];\n\n    // Collect pellets\n    if (cellType === CellType.PELLET) {\n      this.gameState.maze[gridY][gridX] = CellType.EMPTY;\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\n      this.gameState.pelletsRemaining--;\n      this.playSound('CHOMP');\n    }\n\n    // Collect power pellets\n    if (cellType === CellType.POWER_PELLET) {\n      this.gameState.maze[gridY][gridX] = CellType.EMPTY;\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\n      this.gameState.pelletsRemaining--;\n      this.activatePowerPellet();\n      this.playSound('POWER_PELLET');\n    }\n\n    // Collect fruit\n    if (this.gameState.fruitPosition && gridX === this.gameState.fruitPosition.x && gridY === this.gameState.fruitPosition.y) {\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\n      this.gameState.score += fruitPoints;\n      this.gameState.fruitScore = fruitPoints;\n      this.gameState.fruitPosition = null;\n      this.gameState.fruitSpawned = false;\n      this.playSound('FRUIT');\n    }\n\n    // Check ghost collisions\n    this.gameState.ghosts.forEach(ghost => {\n      const ghostGridX = Math.round(ghost.position.x / GAME_CONFIG.CELL_SIZE);\n      const ghostGridY = Math.round(ghost.position.y / GAME_CONFIG.CELL_SIZE);\n      const distance = Math.abs(gridX - ghostGridX) + Math.abs(gridY - ghostGridY);\n      if (distance < 1) {\n        if (ghost.state === GhostState.FRIGHTENED) {\n          // Eat ghost\n          ghost.state = GhostState.EATEN;\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\n          this.gameState.score += points;\n          this.gameState.ghostEatenCount++;\n          this.gameState.screenShake = true;\n          this.playSound('GHOST_EATEN');\n        } else if (ghost.state !== GhostState.EATEN) {\n          // Pac-Man dies\n          this.gameState.pacman.isDead = true;\n          this.gameState.lives--;\n          this.gameState.screenShake = true;\n          this.playSound('DEATH');\n          if (this.gameState.lives <= 0) {\n            this.gameState.gameStatus = 'GAME_OVER';\n          } else {\n            // Reset positions\n            setTimeout(() => this.resetPositions(), 2000);\n          }\n        }\n      }\n    });\n  }\n\n  /**\r\n   * Activate power pellet effect\r\n   */\n  activatePowerPellet() {\n    this.gameState.powerPelletActive = true;\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\n    this.gameState.ghostEatenCount = 0;\n\n    // Make ghosts frightened\n    this.gameState.ghosts.forEach(ghost => {\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\n        ghost.state = GhostState.FRIGHTENED;\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\n        ghost.isFlashing = false;\n        // Reverse direction\n        ghost.direction = this.getOppositeDirection(ghost.direction);\n      }\n    });\n  }\n\n  /**\r\n   * Update power pellet timer\r\n   */\n  updatePowerPelletTimer() {\n    if (this.gameState.powerPelletActive) {\n      this.gameState.powerPelletTimer--;\n      if (this.gameState.powerPelletTimer <= 0) {\n        this.gameState.powerPelletActive = false;\n      }\n    }\n  }\n\n  /**\r\n   * Update AI analysis and danger map\r\n   */\n  updateAIAnalysis() {\n    if (this.frameCount % 10 === 0) {\n      // Update every 6th of a second\n      // const analysis = this.aiEngine.analyzeGameState(\n      //   this.gameState.pacman,\n      //   this.gameState.ghosts,\n      //   this.gameState.maze\n      // );\n\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(this.gameState.ghosts, this.gameState.maze);\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\n    }\n  }\n\n  /**\r\n   * Check win/lose conditions\r\n   */\n  checkGameConditions() {\n    // Check if all pellets collected\n    if (this.gameState.pelletsRemaining <= 0) {\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\n      this.gameState.level++;\n\n      // Reset maze and positions for next level\n      setTimeout(() => {\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\n        this.resetPositions();\n        this.gameState.gameStatus = 'READY';\n      }, 2000);\n    }\n\n    // Update high score\n    if (this.gameState.score > this.gameState.highScore) {\n      this.gameState.highScore = this.gameState.score;\n      localStorage.setItem('pacman_highscore', this.gameState.score.toString());\n    }\n  }\n\n  /**\r\n   * Update visual effects\r\n   */\n  updateVisualEffects() {\n    // Reset screen shake\n    if (this.gameState.screenShake) {\n      setTimeout(() => {\n        this.gameState.screenShake = false;\n      }, 200);\n    }\n\n    // Random VHS glitch effect\n    if (Math.random() < 0.001) {\n      this.gameState.vhsGlitch = true;\n      setTimeout(() => {\n        this.gameState.vhsGlitch = false;\n      }, 100);\n    }\n  }\n\n  /**\r\n   * Update fruit spawning logic\r\n   */\n  updateFruitSpawning() {\n    if (!this.gameState.fruitSpawned && this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\n      // Spawn fruit when 70% of pellets are eaten\n      this.gameState.fruitSpawned = true;\n      this.gameState.fruitPosition = {\n        x: 9,\n        y: 15\n      }; // Center of maze (grid coordinates)\n\n      // Remove fruit after 10 seconds\n      setTimeout(() => {\n        this.gameState.fruitPosition = null;\n        this.gameState.fruitSpawned = false;\n      }, 10000);\n    }\n  }\n\n  // Helper methods\n\n  getGhostTarget(ghost) {\n    const pacman = this.gameState.pacman;\n    switch (ghost.id) {\n      case GhostType.BLINKY:\n        return pacman.position;\n      case GhostType.PINKY:\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\n      case GhostType.INKY:\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\n        if (blinky) {\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\n          return {\n            x: ahead.x + (ahead.x - blinky.position.x),\n            y: ahead.y + (ahead.y - blinky.position.y)\n          };\n        }\n        return pacman.position;\n      case GhostType.CLYDE:\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\n      default:\n        return pacman.position;\n    }\n  }\n  getNextPosition(position, direction) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: position.y - 1\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: position.y + 1\n        };\n      case Direction.LEFT:\n        return {\n          x: position.x - 1,\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: position.x + 1,\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getPositionAhead(position, direction, distance) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: Math.max(0, position.y - distance)\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance)\n        };\n      case Direction.LEFT:\n        return {\n          x: Math.max(0, position.x - distance),\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance),\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getOppositeDirection(direction) {\n    switch (direction) {\n      case Direction.UP:\n        return Direction.DOWN;\n      case Direction.DOWN:\n        return Direction.UP;\n      case Direction.LEFT:\n        return Direction.RIGHT;\n      case Direction.RIGHT:\n        return Direction.LEFT;\n      default:\n        return Direction.NONE;\n    }\n  }\n  getPossibleDirections(position) {\n    const directions = [];\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\n      directions.push(Direction.UP);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\n      directions.push(Direction.DOWN);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\n      directions.push(Direction.LEFT);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\n      directions.push(Direction.RIGHT);\n    }\n    return directions;\n  }\n  isValidMove(position) {\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\n    const cellType = this.gameState.maze[position.y][position.x];\n    return cellType !== CellType.WALL;\n  }\n  setVelocity(entity, direction) {\n    const speed = GAME_CONFIG.PACMAN_SPEED;\n    switch (direction) {\n      case Direction.UP:\n        entity.velocity = {\n          dx: 0,\n          dy: -speed\n        };\n        break;\n      case Direction.DOWN:\n        entity.velocity = {\n          dx: 0,\n          dy: speed\n        };\n        break;\n      case Direction.LEFT:\n        entity.velocity = {\n          dx: -speed,\n          dy: 0\n        };\n        break;\n      case Direction.RIGHT:\n        entity.velocity = {\n          dx: speed,\n          dy: 0\n        };\n        break;\n      default:\n        entity.velocity = {\n          dx: 0,\n          dy: 0\n        };\n    }\n  }\n  setGhostVelocity(ghost) {\n    let speed = GAME_CONFIG.GHOST_SPEED * this.difficultyMultiplier;\n    if (ghost.state === GhostState.FRIGHTENED) {\n      speed = GAME_CONFIG.FRIGHTENED_SPEED * this.difficultyMultiplier;\n    } else if (ghost.state === GhostState.EATEN) {\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5 * this.difficultyMultiplier; // Faster when returning to house\n    }\n    switch (ghost.direction) {\n      case Direction.UP:\n        ghost.velocity = {\n          dx: 0,\n          dy: -speed\n        };\n        break;\n      case Direction.DOWN:\n        ghost.velocity = {\n          dx: 0,\n          dy: speed\n        };\n        break;\n      case Direction.LEFT:\n        ghost.velocity = {\n          dx: -speed,\n          dy: 0\n        };\n        break;\n      case Direction.RIGHT:\n        ghost.velocity = {\n          dx: speed,\n          dy: 0\n        };\n        break;\n      default:\n        ghost.velocity = {\n          dx: 0,\n          dy: 0\n        };\n    }\n  }\n  manhattanDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n  }\n  countPellets(maze) {\n    let count = 0;\n    maze.forEach(row => {\n      row.forEach(cell => {\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\n          count++;\n        }\n      });\n    });\n    return count;\n  }\n  resetPositions() {\n    this.gameState.pacman.position = {\n      x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE,\n      y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE\n    };\n    this.gameState.pacman.direction = Direction.NONE;\n    this.gameState.pacman.velocity = {\n      dx: 0,\n      dy: 0\n    };\n    this.gameState.pacman.isDead = false;\n    this.gameState.ghosts.forEach(ghost => {\n      const config = GHOST_CONFIG[ghost.id];\n      ghost.position = {\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE,\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE\n      };\n      ghost.direction = Direction.UP;\n      ghost.velocity = {\n        dx: 0,\n        dy: 0\n      };\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\n    });\n    this.gameState.powerPelletActive = false;\n    this.gameState.powerPelletTimer = 0;\n    this.gameState.gameStatus = 'READY';\n  }\n  playSound(soundName) {\n    // Sound implementation would go here\n    // For now, just log the sound that would be played\n    console.log(`Playing sound: ${soundName}`);\n  }\n\n  // Public methods for external access\n\n  getGameState() {\n    return this.gameState;\n  }\n  startGame() {\n    this.gameState.gameStatus = 'PLAYING';\n  }\n  pauseGame() {\n    this.gameState.gameStatus = 'PAUSED';\n  }\n  resumeGame() {\n    this.gameState.gameStatus = 'PLAYING';\n  }\n  restartGame() {\n    this.gameState = this.initializeGameState();\n  }\n  toggleAIFeatures() {\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\n  }\n  setDifficulty(multiplier) {\n    this.difficultyMultiplier = multiplier;\n  }\n}","map":{"version":3,"names":["Direction","CellType","GhostState","GhostType","GAME_CONFIG","MAZE_LAYOUT","GHOST_CONFIG","PACMAN_START_POSITION","AIEngine","GameEngine","constructor","aiEngine","gameState","lastUpdateTime","frameCount","difficultyMultiplier","initializeGameState","maze","map","row","pelletsRemaining","countPellets","pacman","createPacMan","ghosts","createGhosts","score","highScore","parseInt","localStorage","getItem","lives","level","powerPelletActive","powerPelletTimer","gameStatus","ghostEatenCount","fruitSpawned","fruitPosition","fruitScore","aiLearningLevel","showAIFeatures","dangerMap","playerPatterns","screenShake","vhsGlitch","position","x","CELL_SIZE","y","velocity","dx","dy","direction","NONE","nextDirection","animationFrame","isDead","mouthOpen","Object","entries","type","config","id","startPosition","UP","state","CHASE","IN_HOUSE","color","targetPosition","scatterTarget","houseTimer","keys","indexOf","frightenedTimer","isFlashing","lastDirection","pathPrediction","update","currentTime","inputDirection","updatePacMan","updateGhosts","checkCollisions","updatePowerPelletTimer","updateAIAnalysis","checkGameConditions","updateVisualEffects","updateFruitSpawning","recordPlayerMovement","gridX","Math","round","gridY","nextGridPos","getNextPosition","isValidMove","setVelocity","nextX","nextY","MAZE_WIDTH","forEach","ghost","updateGhostState","updateGhostMovement","updateGhostAnimation","FRIGHTENED","GHOST_FLASH_DURATION","floor","EATEN","housePos","adaptGhostBehavior","modeTime","SCATTER","DOWN","setGhostVelocity","gridPos","possibleDirections","getPossibleDirections","filter","dir","getOppositeDirection","length","bestDirection","shortestDistance","Infinity","random","targetGridX","targetGridY","nextPos","distance","manhattanDistance","nextGridX","nextGridY","predictions","predictGhostMovements","pacmanPos","MAZE_HEIGHT","cellType","PELLET","EMPTY","POINTS_PELLET","playSound","POWER_PELLET","POINTS_POWER_PELLET","activatePowerPellet","fruitPoints","POINTS_FRUIT","min","ghostGridX","ghostGridY","abs","points","POINTS_GHOST_BASE","pow","setTimeout","resetPositions","POWER_PELLET_DURATION","generateDangerHeatmap","getLearningLevel","getPlayerPatterns","setItem","toString","getGhostTarget","BLINKY","PINKY","getPositionAhead","INKY","blinky","find","g","ahead","CLYDE","LEFT","RIGHT","max","directions","push","WALL","entity","speed","PACMAN_SPEED","GHOST_SPEED","FRIGHTENED_SPEED","pos1","pos2","count","cell","soundName","console","log","getGameState","startGame","pauseGame","resumeGame","restartGame","toggleAIFeatures","setDifficulty","multiplier"],"sources":["C:/Users/VEDANT/Desktop/Src/Pacman/src/engine/GameEngine.ts"],"sourcesContent":["import {\r\n  GameState,\r\n  PacMan,\r\n  Ghost,\r\n  Position,\r\n  Direction,\r\n  CellType,\r\n  GhostState,\r\n  GhostType\r\n} from '../types/game.ts';\r\nimport {\r\n  GAME_CONFIG,\r\n  MAZE_LAYOUT,\r\n  GHOST_CONFIG,\r\n  PACMAN_START_POSITION\r\n} from '../config/gameConfig.ts';\r\nimport { AIEngine } from './AIEngine.ts';\r\n\r\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\r\nexport class GameEngine {\r\n  private aiEngine: AIEngine;\r\n  private gameState: GameState;\r\n  private lastUpdateTime: number = 0;\r\n  private frameCount: number = 0;\r\n  private difficultyMultiplier: number = 1.0;\r\n\r\n  constructor() {\r\n    this.aiEngine = new AIEngine();\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  /**\r\n   * Initialize the game state with default values\r\n   */\r\n  private initializeGameState(): GameState {\r\n    const maze = MAZE_LAYOUT.map(row => [...row]);\r\n    const pelletsRemaining = this.countPellets(maze);\r\n\r\n    return {\r\n      pacman: this.createPacMan(),\r\n      ghosts: this.createGhosts(),\r\n      maze,\r\n      score: 0,\r\n      highScore: parseInt(localStorage.getItem('pacman_highscore') || '0'),\r\n      lives: 3,\r\n      level: 1,\r\n      pelletsRemaining,\r\n      powerPelletActive: false,\r\n      powerPelletTimer: 0,\r\n      gameStatus: 'READY',\r\n      ghostEatenCount: 0,\r\n      fruitSpawned: false,\r\n      fruitPosition: null,\r\n      fruitScore: 0,\r\n      aiLearningLevel: 0,\r\n      showAIFeatures: true,\r\n      dangerMap: [],\r\n      playerPatterns: [],\r\n      screenShake: false,\r\n      vhsGlitch: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\r\n  private createPacMan(): PacMan {\r\n    return {\r\n      position: {\r\n        x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE,\r\n        y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE\r\n      },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.NONE,\r\n      nextDirection: Direction.NONE,\r\n      animationFrame: 0,\r\n      isDead: false,\r\n      mouthOpen: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\r\n  private createGhosts(): Ghost[] {\r\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\r\n      id: type as GhostType,\r\n      position: {\r\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE,\r\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE\r\n      },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.UP,\r\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\r\n      color: config.color,\r\n      targetPosition: {\r\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE,\r\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE\r\n      },\r\n      scatterTarget: {\r\n        x: config.scatterTarget.x * GAME_CONFIG.CELL_SIZE,\r\n        y: config.scatterTarget.y * GAME_CONFIG.CELL_SIZE\r\n      },\r\n      houseTimer: type === 'BLINKY' ? 0 : 60 + (Object.keys(GHOST_CONFIG).indexOf(type) * 30),\r\n      frightenedTimer: 0,\r\n      isFlashing: false,\r\n      lastDirection: Direction.UP,\r\n      pathPrediction: []\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\r\n  update(currentTime: number, inputDirection: Direction): GameState {\r\n    // const deltaTime = currentTime - this.lastUpdateTime;\r\n    this.lastUpdateTime = currentTime;\r\n    this.frameCount++;\r\n\r\n    if (this.gameState.gameStatus !== 'PLAYING') {\r\n      return this.gameState;\r\n    }\r\n\r\n    // Update Pac-Man\r\n    this.updatePacMan(inputDirection);\r\n\r\n    // Update ghosts\r\n    this.updateGhosts();\r\n\r\n    // Check collisions\r\n    this.checkCollisions();\r\n\r\n    // Update power pellet timer\r\n    this.updatePowerPelletTimer();\r\n\r\n    // Update AI analysis\r\n    this.updateAIAnalysis();\r\n\r\n    // Check win/lose conditions\r\n    this.checkGameConditions();\r\n\r\n    // Update visual effects\r\n    this.updateVisualEffects();\r\n\r\n    // Spawn fruit occasionally\r\n    this.updateFruitSpawning();\r\n\r\n    return this.gameState;\r\n  }\r\n\r\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\r\n  private updatePacMan(inputDirection: Direction): void {\r\n    const pacman = this.gameState.pacman;\r\n\r\n    // Handle direction changes\r\n    if (inputDirection !== Direction.NONE) {\r\n      pacman.nextDirection = inputDirection;\r\n\r\n      // Record movement for AI learning\r\n      this.aiEngine.recordPlayerMovement(inputDirection);\r\n    }\r\n\r\n    // Try to change direction if possible\r\n    if (pacman.nextDirection !== pacman.direction && pacman.nextDirection !== Direction.NONE) {\r\n      const gridX = Math.round(pacman.position.x / GAME_CONFIG.CELL_SIZE);\r\n      const gridY = Math.round(pacman.position.y / GAME_CONFIG.CELL_SIZE);\r\n      const nextGridPos = this.getNextPosition({ x: gridX, y: gridY }, pacman.nextDirection);\r\n\r\n      if (this.isValidMove(nextGridPos)) {\r\n        pacman.direction = pacman.nextDirection;\r\n        this.setVelocity(pacman, pacman.direction);\r\n      }\r\n    }\r\n\r\n    // Move Pac-Man\r\n    if (pacman.direction !== Direction.NONE) {\r\n      let nextX = pacman.position.x + pacman.velocity.dx;\r\n      let nextY = pacman.position.y + pacman.velocity.dy;\r\n\r\n      // Handle tunnel wraparound\r\n      if (nextX < 0) {\r\n        nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\r\n      } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\r\n        nextX = 0;\r\n      }\r\n\r\n      // Check if move is valid by converting to grid coordinates\r\n      const gridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\r\n      const gridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\r\n\r\n      if (this.isValidMove({ x: gridX, y: gridY })) {\r\n        pacman.position.x = nextX;\r\n        pacman.position.y = nextY;\r\n      } else {\r\n        // Stop if hitting wall\r\n        pacman.direction = Direction.NONE;\r\n        pacman.velocity = { dx: 0, dy: 0 };\r\n      }\r\n    }\r\n\r\n    // Update animation\r\n    if (this.frameCount % 8 === 0) {\r\n      pacman.mouthOpen = !pacman.mouthOpen;\r\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\r\n  private updateGhosts(): void {\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      this.updateGhostState(ghost);\r\n      this.updateGhostMovement(ghost);\r\n      this.updateGhostAnimation(ghost);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update individual ghost state and target\r\n   */\r\n  private updateGhostState(ghost: Ghost): void {\r\n    // Handle house timer\r\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\r\n      ghost.houseTimer--;\r\n      if (ghost.houseTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle frightened state\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      ghost.frightenedTimer--;\r\n\r\n      // Start flashing when timer is low\r\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\r\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\r\n      }\r\n\r\n      if (ghost.frightenedTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n        ghost.isFlashing = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle eaten state\r\n    if (ghost.state === GhostState.EATEN) {\r\n      // Return to house\r\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\r\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      ghost.targetPosition = housePos;\r\n      return;\r\n    }\r\n\r\n    // Normal chase/scatter behavior with AI adaptation\r\n    // const baseTarget = this.getGhostTarget(ghost);\r\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(\r\n      ghost,\r\n      this.gameState.pacman,\r\n      this.gameState.ghosts\r\n    );\r\n\r\n    // Alternate between chase and scatter modes\r\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\r\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\r\n  }\r\n\r\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\r\n  private updateGhostMovement(ghost: Ghost): void {\r\n    if (ghost.state === GhostState.IN_HOUSE) {\r\n      // Simple up-down movement in house\r\n      if (this.frameCount % 60 < 30) {\r\n        ghost.direction = Direction.UP;\r\n      } else {\r\n        ghost.direction = Direction.DOWN;\r\n      }\r\n      this.setGhostVelocity(ghost);\r\n      return;\r\n    }\r\n\r\n    // Convert ghost position to grid coordinates for pathfinding\r\n    const gridX = Math.round(ghost.position.x / GAME_CONFIG.CELL_SIZE);\r\n    const gridY = Math.round(ghost.position.y / GAME_CONFIG.CELL_SIZE);\r\n    const gridPos = { x: gridX, y: gridY };\r\n\r\n    // Get possible directions (can't reverse unless frightened)\r\n    const possibleDirections = this.getPossibleDirections(gridPos)\r\n      .filter(dir => {\r\n        if (ghost.state === GhostState.FRIGHTENED) return true;\r\n        return this.getOppositeDirection(dir) !== ghost.lastDirection;\r\n      });\r\n\r\n    if (possibleDirections.length === 0) return;\r\n\r\n    // Choose direction based on target\r\n    let bestDirection = possibleDirections[0];\r\n    let shortestDistance = Infinity;\r\n\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      // Random movement when frightened\r\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\r\n    } else {\r\n      // Move toward target\r\n      const targetGridX = Math.round(ghost.targetPosition.x / GAME_CONFIG.CELL_SIZE);\r\n      const targetGridY = Math.round(ghost.targetPosition.y / GAME_CONFIG.CELL_SIZE);\r\n\r\n      possibleDirections.forEach(direction => {\r\n        const nextPos = this.getNextPosition(gridPos, direction);\r\n        const distance = this.manhattanDistance(nextPos, { x: targetGridX, y: targetGridY });\r\n\r\n        if (distance < shortestDistance) {\r\n          shortestDistance = distance;\r\n          bestDirection = direction;\r\n        }\r\n      });\r\n    }\r\n\r\n    ghost.lastDirection = ghost.direction;\r\n    ghost.direction = bestDirection;\r\n    this.setGhostVelocity(ghost);\r\n\r\n    // Move ghost\r\n    let nextX = ghost.position.x + ghost.velocity.dx;\r\n    let nextY = ghost.position.y + ghost.velocity.dy;\r\n\r\n    // Handle tunnel wraparound\r\n    if (nextX < 0) {\r\n      nextX = (GAME_CONFIG.MAZE_WIDTH - 1) * GAME_CONFIG.CELL_SIZE;\r\n    } else if (nextX >= GAME_CONFIG.MAZE_WIDTH * GAME_CONFIG.CELL_SIZE) {\r\n      nextX = 0;\r\n    }\r\n\r\n    // Check if move is valid by converting to grid coordinates\r\n    const nextGridX = Math.round(nextX / GAME_CONFIG.CELL_SIZE);\r\n    const nextGridY = Math.round(nextY / GAME_CONFIG.CELL_SIZE);\r\n\r\n    if (this.isValidMove({ x: nextGridX, y: nextGridY })) {\r\n      ghost.position.x = nextX;\r\n      ghost.position.y = nextY;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\r\n  private updateGhostAnimation(ghost: Ghost): void {\r\n    // Update path prediction for AI visualization\r\n    if (this.frameCount % 30 === 0) { // Update every half second\r\n      const predictions = this.aiEngine.predictGhostMovements(\r\n        [ghost],\r\n        this.gameState.maze,\r\n        this.gameState.pacman\r\n      );\r\n      ghost.pathPrediction = predictions[ghost.id] || [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\r\n  private checkCollisions(): void {\r\n    const pacmanPos = this.gameState.pacman.position;\r\n    const gridX = Math.round(pacmanPos.x / GAME_CONFIG.CELL_SIZE);\r\n    const gridY = Math.round(pacmanPos.y / GAME_CONFIG.CELL_SIZE);\r\n\r\n    // Ensure we're within bounds\r\n    if (gridX < 0 || gridX >= GAME_CONFIG.MAZE_WIDTH || gridY < 0 || gridY >= GAME_CONFIG.MAZE_HEIGHT) {\r\n      return;\r\n    }\r\n\r\n    const cellType = this.gameState.maze[gridY][gridX];\r\n\r\n    // Collect pellets\r\n    if (cellType === CellType.PELLET) {\r\n      this.gameState.maze[gridY][gridX] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.playSound('CHOMP');\r\n    }\r\n\r\n    // Collect power pellets\r\n    if (cellType === CellType.POWER_PELLET) {\r\n      this.gameState.maze[gridY][gridX] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.activatePowerPellet();\r\n      this.playSound('POWER_PELLET');\r\n    }\r\n\r\n    // Collect fruit\r\n    if (this.gameState.fruitPosition &&\r\n      gridX === this.gameState.fruitPosition.x &&\r\n      gridY === this.gameState.fruitPosition.y) {\r\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\r\n      this.gameState.score += fruitPoints;\r\n      this.gameState.fruitScore = fruitPoints;\r\n      this.gameState.fruitPosition = null;\r\n      this.gameState.fruitSpawned = false;\r\n      this.playSound('FRUIT');\r\n    }\r\n\r\n    // Check ghost collisions\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      const ghostGridX = Math.round(ghost.position.x / GAME_CONFIG.CELL_SIZE);\r\n      const ghostGridY = Math.round(ghost.position.y / GAME_CONFIG.CELL_SIZE);\r\n      const distance = Math.abs(gridX - ghostGridX) + Math.abs(gridY - ghostGridY);\r\n\r\n      if (distance < 1) {\r\n        if (ghost.state === GhostState.FRIGHTENED) {\r\n          // Eat ghost\r\n          ghost.state = GhostState.EATEN;\r\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\r\n          this.gameState.score += points;\r\n          this.gameState.ghostEatenCount++;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('GHOST_EATEN');\r\n        } else if (ghost.state !== GhostState.EATEN) {\r\n          // Pac-Man dies\r\n          this.gameState.pacman.isDead = true;\r\n          this.gameState.lives--;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('DEATH');\r\n\r\n          if (this.gameState.lives <= 0) {\r\n            this.gameState.gameStatus = 'GAME_OVER';\r\n          } else {\r\n            // Reset positions\r\n            setTimeout(() => this.resetPositions(), 2000);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate power pellet effect\r\n   */\r\n  private activatePowerPellet(): void {\r\n    this.gameState.powerPelletActive = true;\r\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n    this.gameState.ghostEatenCount = 0;\r\n\r\n    // Make ghosts frightened\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\r\n        ghost.state = GhostState.FRIGHTENED;\r\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n        ghost.isFlashing = false;\r\n        // Reverse direction\r\n        ghost.direction = this.getOppositeDirection(ghost.direction);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update power pellet timer\r\n   */\r\n  private updatePowerPelletTimer(): void {\r\n    if (this.gameState.powerPelletActive) {\r\n      this.gameState.powerPelletTimer--;\r\n      if (this.gameState.powerPelletTimer <= 0) {\r\n        this.gameState.powerPelletActive = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update AI analysis and danger map\r\n   */\r\n  private updateAIAnalysis(): void {\r\n    if (this.frameCount % 10 === 0) { // Update every 6th of a second\r\n      // const analysis = this.aiEngine.analyzeGameState(\r\n      //   this.gameState.pacman,\r\n      //   this.gameState.ghosts,\r\n      //   this.gameState.maze\r\n      // );\r\n\r\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(\r\n        this.gameState.ghosts,\r\n        this.gameState.maze\r\n      );\r\n\r\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\r\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check win/lose conditions\r\n   */\r\n  private checkGameConditions(): void {\r\n    // Check if all pellets collected\r\n    if (this.gameState.pelletsRemaining <= 0) {\r\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\r\n      this.gameState.level++;\r\n\r\n      // Reset maze and positions for next level\r\n      setTimeout(() => {\r\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\r\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\r\n        this.resetPositions();\r\n        this.gameState.gameStatus = 'READY';\r\n      }, 2000);\r\n    }\r\n\r\n    // Update high score\r\n    if (this.gameState.score > this.gameState.highScore) {\r\n      this.gameState.highScore = this.gameState.score;\r\n      localStorage.setItem('pacman_highscore', this.gameState.score.toString());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update visual effects\r\n   */\r\n  private updateVisualEffects(): void {\r\n    // Reset screen shake\r\n    if (this.gameState.screenShake) {\r\n      setTimeout(() => {\r\n        this.gameState.screenShake = false;\r\n      }, 200);\r\n    }\r\n\r\n    // Random VHS glitch effect\r\n    if (Math.random() < 0.001) {\r\n      this.gameState.vhsGlitch = true;\r\n      setTimeout(() => {\r\n        this.gameState.vhsGlitch = false;\r\n      }, 100);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update fruit spawning logic\r\n   */\r\n  private updateFruitSpawning(): void {\r\n    if (!this.gameState.fruitSpawned &&\r\n      this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\r\n      // Spawn fruit when 70% of pellets are eaten\r\n      this.gameState.fruitSpawned = true;\r\n      this.gameState.fruitPosition = { x: 9, y: 15 }; // Center of maze (grid coordinates)\r\n\r\n      // Remove fruit after 10 seconds\r\n      setTimeout(() => {\r\n        this.gameState.fruitPosition = null;\r\n        this.gameState.fruitSpawned = false;\r\n      }, 10000);\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  private getGhostTarget(ghost: Ghost): Position {\r\n    const pacman = this.gameState.pacman;\r\n\r\n    switch (ghost.id) {\r\n      case GhostType.BLINKY:\r\n        return pacman.position;\r\n\r\n      case GhostType.PINKY:\r\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\r\n\r\n      case GhostType.INKY:\r\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\r\n        if (blinky) {\r\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\r\n          return {\r\n            x: ahead.x + (ahead.x - blinky.position.x),\r\n            y: ahead.y + (ahead.y - blinky.position.y)\r\n          };\r\n        }\r\n        return pacman.position;\r\n\r\n      case GhostType.CLYDE:\r\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\r\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\r\n\r\n      default:\r\n        return pacman.position;\r\n    }\r\n  }\r\n\r\n  private getNextPosition(position: Position, direction: Direction): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - 1 };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + 1 };\r\n      case Direction.LEFT:\r\n        return { x: position.x - 1, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + 1, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getPositionAhead(position: Position, direction: Direction, distance: number): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: Math.max(0, position.y - distance) };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance) };\r\n      case Direction.LEFT:\r\n        return { x: Math.max(0, position.x - distance), y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance), y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getOppositeDirection(direction: Direction): Direction {\r\n    switch (direction) {\r\n      case Direction.UP: return Direction.DOWN;\r\n      case Direction.DOWN: return Direction.UP;\r\n      case Direction.LEFT: return Direction.RIGHT;\r\n      case Direction.RIGHT: return Direction.LEFT;\r\n      default: return Direction.NONE;\r\n    }\r\n  }\r\n\r\n  private getPossibleDirections(position: Position): Direction[] {\r\n    const directions: Direction[] = [];\r\n\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\r\n      directions.push(Direction.UP);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\r\n      directions.push(Direction.DOWN);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\r\n      directions.push(Direction.LEFT);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\r\n      directions.push(Direction.RIGHT);\r\n    }\r\n\r\n    return directions;\r\n  }\r\n\r\n  private isValidMove(position: Position): boolean {\r\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\r\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\r\n\r\n    const cellType = this.gameState.maze[position.y][position.x];\r\n    return cellType !== CellType.WALL;\r\n  }\r\n\r\n  private setVelocity(entity: PacMan, direction: Direction): void {\r\n    const speed = GAME_CONFIG.PACMAN_SPEED;\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        entity.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        entity.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        entity.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        entity.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        entity.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private setGhostVelocity(ghost: Ghost): void {\r\n    let speed = GAME_CONFIG.GHOST_SPEED * this.difficultyMultiplier;\r\n\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      speed = GAME_CONFIG.FRIGHTENED_SPEED * this.difficultyMultiplier;\r\n    } else if (ghost.state === GhostState.EATEN) {\r\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5 * this.difficultyMultiplier; // Faster when returning to house\r\n    }\r\n\r\n    switch (ghost.direction) {\r\n      case Direction.UP:\r\n        ghost.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        ghost.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        ghost.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        ghost.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        ghost.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private manhattanDistance(pos1: Position, pos2: Position): number {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n  }\r\n\r\n  private countPellets(maze: CellType[][]): number {\r\n    let count = 0;\r\n    maze.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\r\n          count++;\r\n        }\r\n      });\r\n    });\r\n    return count;\r\n  }\r\n\r\n  private resetPositions(): void {\r\n    this.gameState.pacman.position = {\r\n      x: PACMAN_START_POSITION.x * GAME_CONFIG.CELL_SIZE,\r\n      y: PACMAN_START_POSITION.y * GAME_CONFIG.CELL_SIZE\r\n    };\r\n    this.gameState.pacman.direction = Direction.NONE;\r\n    this.gameState.pacman.velocity = { dx: 0, dy: 0 };\r\n    this.gameState.pacman.isDead = false;\r\n\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      const config = GHOST_CONFIG[ghost.id];\r\n      ghost.position = {\r\n        x: config.startPosition.x * GAME_CONFIG.CELL_SIZE,\r\n        y: config.startPosition.y * GAME_CONFIG.CELL_SIZE\r\n      };\r\n      ghost.direction = Direction.UP;\r\n      ghost.velocity = { dx: 0, dy: 0 };\r\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\r\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\r\n    });\r\n\r\n    this.gameState.powerPelletActive = false;\r\n    this.gameState.powerPelletTimer = 0;\r\n    this.gameState.gameStatus = 'READY';\r\n  }\r\n\r\n  private playSound(soundName: string): void {\r\n    // Sound implementation would go here\r\n    // For now, just log the sound that would be played\r\n    console.log(`Playing sound: ${soundName}`);\r\n  }\r\n\r\n  // Public methods for external access\r\n\r\n  getGameState(): GameState {\r\n    return this.gameState;\r\n  }\r\n\r\n  startGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  pauseGame(): void {\r\n    this.gameState.gameStatus = 'PAUSED';\r\n  }\r\n\r\n  resumeGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  restartGame(): void {\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  toggleAIFeatures(): void {\r\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\r\n  }\r\n\r\n  setDifficulty(multiplier: number): void {\r\n    this.difficultyMultiplier = multiplier;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}