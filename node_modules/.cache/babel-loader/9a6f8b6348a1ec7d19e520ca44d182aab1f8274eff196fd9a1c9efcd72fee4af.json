{"ast":null,"code":"import { Direction, CellType, GhostState, GhostType } from '../types/game.ts';\nimport { GAME_CONFIG, AI_CONFIG } from '../config/gameConfig.ts';\n\n/**\r\n * AI Engine for Pac-Man game\r\n * Implements three core AI features:\r\n * 1. Predictive Path Display - Shows ghost movement predictions\r\n * 2. Danger Zone Heatmap - Real-time danger visualization\r\n * 3. Adaptive Ghost Intelligence - Learning from player patterns\r\n */\nexport class AIEngine {\n  constructor() {\n    this.playerPatterns = [];\n    this.patternWeights = {\n      [Direction.UP]: 0,\n      [Direction.DOWN]: 0,\n      [Direction.LEFT]: 0,\n      [Direction.RIGHT]: 0,\n      [Direction.NONE]: 0\n    };\n    this.learningLevel = 0;\n  }\n  /**\r\n   * Analyzes current game state and provides AI insights\r\n   */\n  analyzeGameState(pacman, ghosts, maze) {\n    const ghostPredictions = this.predictGhostMovements(ghosts, maze, pacman);\n    const dangerLevel = this.calculateDangerLevel(pacman.position, ghosts);\n    const suggestedDirection = this.suggestOptimalDirection(pacman, ghosts, maze);\n    const safeZones = this.findSafeZones(pacman.position, ghosts, maze);\n    const escapeRoutes = this.findEscapeRoutes(pacman.position, ghosts, maze);\n    return {\n      dangerLevel,\n      suggestedDirection,\n      ghostPredictions,\n      safeZones,\n      escapeRoutes,\n      playerTendencies: {\n        ...this.patternWeights\n      }\n    };\n  }\n\n  /**\r\n   * Predicts ghost movements using A* pathfinding and behavior patterns\r\n   */\n  predictGhostMovements(ghosts, maze, pacman) {\n    const predictions = {\n      [GhostType.BLINKY]: [],\n      [GhostType.PINKY]: [],\n      [GhostType.INKY]: [],\n      [GhostType.CLYDE]: []\n    };\n    ghosts.forEach(ghost => {\n      if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\n        // Frightened ghosts move randomly, harder to predict\n        predictions[ghost.id] = this.predictRandomMovement(ghost, maze);\n      } else {\n        // Use A* pathfinding to predict chase/scatter behavior\n        const target = this.getGhostTarget(ghost, pacman, ghosts);\n        predictions[ghost.id] = this.predictPathToTarget(ghost, target, maze);\n      }\n    });\n    return predictions;\n  }\n\n  /**\r\n   * Calculates danger level at given position based on ghost proximity and states\r\n   */\n  calculateDangerLevel(position, ghosts) {\n    let totalDanger = 0;\n    ghosts.forEach(ghost => {\n      if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\n        return; // No danger from frightened/eaten ghosts\n      }\n      const distance = this.manhattanDistance(position, ghost.position);\n      const maxDangerDistance = AI_CONFIG.DANGER_RADIUS;\n      if (distance <= maxDangerDistance) {\n        // Closer ghosts are more dangerous\n        const dangerContribution = (maxDangerDistance - distance) / maxDangerDistance;\n        totalDanger += dangerContribution;\n      }\n    });\n    return Math.min(totalDanger, 1); // Normalize to 0-1\n  }\n\n  /**\r\n   * Generates danger heatmap for the entire maze\r\n   */\n  generateDangerHeatmap(ghosts, maze) {\n    const heatmap = Array(maze.length).fill(null).map(() => Array(maze[0].length).fill(0));\n    for (let y = 0; y < maze.length; y++) {\n      for (let x = 0; x < maze[0].length; x++) {\n        if (maze[y][x] === CellType.WALL) {\n          heatmap[y][x] = -1; // Mark walls\n          continue;\n        }\n        heatmap[y][x] = this.calculateDangerLevel({\n          x,\n          y\n        }, ghosts);\n      }\n    }\n    return heatmap;\n  }\n\n  /**\r\n   * Records player movement patterns for adaptive AI\r\n   */\n  recordPlayerMovement(direction) {\n    this.playerPatterns.push(direction);\n\n    // Keep only recent patterns\n    if (this.playerPatterns.length > AI_CONFIG.PATTERN_THRESHOLD) {\n      this.playerPatterns.shift();\n    }\n\n    // Update pattern weights\n    this.updatePatternWeights();\n    this.updateLearningLevel();\n  }\n\n  /**\r\n   * Suggests optimal direction based on danger analysis and escape routes\r\n   */\n  suggestOptimalDirection(pacman, ghosts, maze) {\n    const possibleDirections = this.getPossibleDirections(pacman.position, maze);\n    let bestDirection = Direction.NONE;\n    let lowestDanger = Infinity;\n    possibleDirections.forEach(direction => {\n      const nextPosition = this.getNextPosition(pacman.position, direction);\n      const danger = this.calculateDangerLevel(nextPosition, ghosts);\n\n      // Consider future danger by looking ahead\n      const futureDanger = this.calculateFutureDanger(nextPosition, ghosts, maze, 3);\n      const totalDanger = danger + futureDanger * 0.5;\n      if (totalDanger < lowestDanger) {\n        lowestDanger = totalDanger;\n        bestDirection = direction;\n      }\n    });\n    return bestDirection;\n  }\n\n  /**\r\n   * Finds safe zones where player can temporarily hide\r\n   */\n  findSafeZones(pacmanPosition, ghosts, maze) {\n    const safeZones = [];\n    const safeDistance = AI_CONFIG.SAFE_DISTANCE;\n    for (let y = 0; y < maze.length; y++) {\n      for (let x = 0; x < maze[0].length; x++) {\n        if (maze[y][x] === CellType.WALL) continue;\n        const position = {\n          x,\n          y\n        };\n        const isSafe = ghosts.every(ghost => {\n          if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\n            return true;\n          }\n          return this.manhattanDistance(position, ghost.position) >= safeDistance;\n        });\n        if (isSafe && this.manhattanDistance(position, pacmanPosition) <= 8) {\n          safeZones.push(position);\n        }\n      }\n    }\n    return safeZones;\n  }\n\n  /**\r\n   * Finds escape routes when surrounded by ghosts\r\n   */\n  findEscapeRoutes(pacmanPosition, ghosts, maze) {\n    const escapeRoutes = [];\n    const visited = new Set();\n    const queue = [{\n      position: pacmanPosition,\n      path: []\n    }];\n    while (queue.length > 0) {\n      const {\n        position,\n        path\n      } = queue.shift();\n      const key = `${position.x},${position.y}`;\n      if (visited.has(key) || path.length > 6) continue;\n      visited.add(key);\n\n      // Check if this position is safe\n      const danger = this.calculateDangerLevel(position, ghosts);\n      if (danger < 0.3 && path.length > 2) {\n        escapeRoutes.push(...path);\n        continue;\n      }\n\n      // Explore adjacent positions\n      const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];\n      directions.forEach(direction => {\n        const nextPos = this.getNextPosition(position, direction);\n        if (this.isValidPosition(nextPos, maze)) {\n          queue.push({\n            position: nextPos,\n            path: [...path, nextPos]\n          });\n        }\n      });\n    }\n    return escapeRoutes;\n  }\n\n  /**\r\n   * Adapts ghost behavior based on learned player patterns\r\n   */\n  adaptGhostBehavior(ghost, pacman, ghosts) {\n    const baseTarget = this.getGhostTarget(ghost, pacman, ghosts);\n    if (this.learningLevel < 20) {\n      return baseTarget; // Not enough learning yet\n    }\n\n    // Predict where player is likely to go based on patterns\n    const predictedDirection = this.predictPlayerDirection();\n    const predictedPosition = this.getNextPosition(pacman.position, predictedDirection);\n\n    // Adjust ghost target to intercept predicted path\n    const interceptTarget = this.calculateInterceptPoint(ghost.position, predictedPosition, pacman.velocity);\n\n    // Blend original target with intercept target based on learning level\n    const learningWeight = Math.min(this.learningLevel / 100, 0.7);\n    return {\n      x: Math.round(baseTarget.x * (1 - learningWeight) + interceptTarget.x * learningWeight),\n      y: Math.round(baseTarget.y * (1 - learningWeight) + interceptTarget.y * learningWeight)\n    };\n  }\n\n  // Private helper methods\n\n  predictRandomMovement(ghost, maze) {\n    const predictions = [];\n    let currentPos = {\n      ...ghost.position\n    };\n    for (let i = 0; i < GAME_CONFIG.AI_PREDICTION_STEPS; i++) {\n      const possibleDirections = this.getPossibleDirections(currentPos, maze);\n      const randomDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n      currentPos = this.getNextPosition(currentPos, randomDirection);\n      predictions.push({\n        ...currentPos\n      });\n    }\n    return predictions;\n  }\n  predictPathToTarget(ghost, target, maze) {\n    const path = this.findPathAStar(ghost.position, target, maze);\n    return path.slice(1, GAME_CONFIG.AI_PREDICTION_STEPS + 1);\n  }\n  findPathAStar(start, goal, maze) {\n    const openSet = [start];\n    const cameFrom = new Map();\n    const gScore = new Map();\n    const fScore = new Map();\n    gScore.set(`${start.x},${start.y}`, 0);\n    fScore.set(`${start.x},${start.y}`, this.manhattanDistance(start, goal));\n    while (openSet.length > 0) {\n      // Find node with lowest fScore\n      let current = openSet[0];\n      let currentIndex = 0;\n      for (let i = 1; i < openSet.length; i++) {\n        const currentKey = `${current.x},${current.y}`;\n        const nodeKey = `${openSet[i].x},${openSet[i].y}`;\n        if ((fScore.get(nodeKey) || Infinity) < (fScore.get(currentKey) || Infinity)) {\n          current = openSet[i];\n          currentIndex = i;\n        }\n      }\n      if (current.x === goal.x && current.y === goal.y) {\n        // Reconstruct path\n        const path = [current];\n        let currentKey = `${current.x},${current.y}`;\n        while (cameFrom.has(currentKey)) {\n          current = cameFrom.get(currentKey);\n          path.unshift(current);\n          currentKey = `${current.x},${current.y}`;\n        }\n        return path;\n      }\n      openSet.splice(currentIndex, 1);\n\n      // Check neighbors\n      const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];\n      directions.forEach(direction => {\n        const neighbor = this.getNextPosition(current, direction);\n        if (!this.isValidPosition(neighbor, maze)) return;\n        const neighborKey = `${neighbor.x},${neighbor.y}`;\n        const tentativeGScore = (gScore.get(`${current.x},${current.y}`) || 0) + 1;\n        if (tentativeGScore < (gScore.get(neighborKey) || Infinity)) {\n          cameFrom.set(neighborKey, current);\n          gScore.set(neighborKey, tentativeGScore);\n          fScore.set(neighborKey, tentativeGScore + this.manhattanDistance(neighbor, goal));\n          if (!openSet.some(pos => pos.x === neighbor.x && pos.y === neighbor.y)) {\n            openSet.push(neighbor);\n          }\n        }\n      });\n    }\n    return []; // No path found\n  }\n  getGhostTarget(ghost, pacman, ghosts) {\n    switch (ghost.id) {\n      case GhostType.BLINKY:\n        // Blinky targets Pac-Man directly\n        return pacman.position;\n      case GhostType.PINKY:\n        // Pinky targets 4 cells ahead of Pac-Man\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\n      case GhostType.INKY:\n        // Inky uses complex targeting involving Blinky\n        const blinky = ghosts.find(g => g.id === GhostType.BLINKY);\n        if (blinky) {\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\n          return {\n            x: ahead.x + (ahead.x - blinky.position.x),\n            y: ahead.y + (ahead.y - blinky.position.y)\n          };\n        }\n        return pacman.position;\n      case GhostType.CLYDE:\n        // Clyde targets Pac-Man when far, scatters when close\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\n      default:\n        return pacman.position;\n    }\n  }\n  updatePatternWeights() {\n    // Reset weights\n    Object.keys(this.patternWeights).forEach(key => {\n      this.patternWeights[key] = 0;\n    });\n\n    // Calculate frequency of each direction\n    this.playerPatterns.forEach(direction => {\n      this.patternWeights[direction]++;\n    });\n\n    // Normalize to percentages\n    const total = this.playerPatterns.length;\n    Object.keys(this.patternWeights).forEach(key => {\n      this.patternWeights[key] /= total;\n    });\n  }\n  updateLearningLevel() {\n    // Learning level increases with pattern consistency\n    const maxWeight = Math.max(...Object.values(this.patternWeights));\n    const consistency = maxWeight - 0.25; // 0.25 is random chance\n\n    if (consistency > 0) {\n      this.learningLevel = Math.min(this.learningLevel + consistency * AI_CONFIG.LEARNING_RATE, AI_CONFIG.MAX_LEARNING_LEVEL);\n    }\n  }\n  predictPlayerDirection() {\n    const weights = this.patternWeights;\n    let maxWeight = 0;\n    let predictedDirection = Direction.NONE;\n    Object.entries(weights).forEach(([direction, weight]) => {\n      if (weight > maxWeight) {\n        maxWeight = weight;\n        predictedDirection = direction;\n      }\n    });\n    return predictedDirection;\n  }\n  calculateInterceptPoint(ghostPos, targetPos, targetVelocity) {\n    // Simple interception calculation\n    const dx = targetPos.x - ghostPos.x;\n    const dy = targetPos.y - ghostPos.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    const timeToReach = distance / GAME_CONFIG.GHOST_SPEED;\n    return {\n      x: Math.round(targetPos.x + targetVelocity.dx * timeToReach),\n      y: Math.round(targetPos.y + targetVelocity.dy * timeToReach)\n    };\n  }\n  calculateFutureDanger(position, ghosts, maze, steps) {\n    let totalDanger = 0;\n    for (let step = 1; step <= steps; step++) {\n      const currentStep = step; // Capture step value to avoid closure issue\n      // eslint-disable-next-line no-loop-func\n      ghosts.forEach(ghost => {\n        if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\n          return;\n        }\n\n        // Estimate ghost position after 'step' moves\n        const futureGhostPos = this.estimateGhostPosition(ghost, currentStep);\n        const distance = this.manhattanDistance(position, futureGhostPos);\n        if (distance <= AI_CONFIG.DANGER_RADIUS) {\n          totalDanger += (AI_CONFIG.DANGER_RADIUS - distance) / AI_CONFIG.DANGER_RADIUS / currentStep;\n        }\n      });\n    }\n    return totalDanger;\n  }\n  estimateGhostPosition(ghost, steps) {\n    // Simple estimation - ghost moves toward its current target\n    const dx = ghost.targetPosition.x - ghost.position.x;\n    const dy = ghost.targetPosition.y - ghost.position.y;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    if (distance === 0) return ghost.position;\n    const normalizedDx = dx / distance;\n    const normalizedDy = dy / distance;\n    return {\n      x: Math.round(ghost.position.x + normalizedDx * GAME_CONFIG.GHOST_SPEED * steps),\n      y: Math.round(ghost.position.y + normalizedDy * GAME_CONFIG.GHOST_SPEED * steps)\n    };\n  }\n  getPossibleDirections(position, maze) {\n    const directions = [];\n    if (this.isValidPosition(this.getNextPosition(position, Direction.UP), maze)) {\n      directions.push(Direction.UP);\n    }\n    if (this.isValidPosition(this.getNextPosition(position, Direction.DOWN), maze)) {\n      directions.push(Direction.DOWN);\n    }\n    if (this.isValidPosition(this.getNextPosition(position, Direction.LEFT), maze)) {\n      directions.push(Direction.LEFT);\n    }\n    if (this.isValidPosition(this.getNextPosition(position, Direction.RIGHT), maze)) {\n      directions.push(Direction.RIGHT);\n    }\n    return directions;\n  }\n  getNextPosition(position, direction) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: position.y - 1\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: position.y + 1\n        };\n      case Direction.LEFT:\n        return {\n          x: position.x - 1,\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: position.x + 1,\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getPositionAhead(position, direction, distance) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: position.y - distance\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: position.y + distance\n        };\n      case Direction.LEFT:\n        return {\n          x: position.x - distance,\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: position.x + distance,\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  isValidPosition(position, maze) {\n    if (position.y < 0 || position.y >= maze.length) return false;\n    if (position.x < 0 || position.x >= maze[0].length) return false;\n    return maze[position.y][position.x] !== CellType.WALL;\n  }\n  manhattanDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n  }\n\n  // Getters for external access\n  getLearningLevel() {\n    return this.learningLevel;\n  }\n  getPlayerPatterns() {\n    return [...this.playerPatterns];\n  }\n  getPatternWeights() {\n    return {\n      ...this.patternWeights\n    };\n  }\n}","map":{"version":3,"names":["Direction","CellType","GhostState","GhostType","GAME_CONFIG","AI_CONFIG","AIEngine","constructor","playerPatterns","patternWeights","UP","DOWN","LEFT","RIGHT","NONE","learningLevel","analyzeGameState","pacman","ghosts","maze","ghostPredictions","predictGhostMovements","dangerLevel","calculateDangerLevel","position","suggestedDirection","suggestOptimalDirection","safeZones","findSafeZones","escapeRoutes","findEscapeRoutes","playerTendencies","predictions","BLINKY","PINKY","INKY","CLYDE","forEach","ghost","state","FRIGHTENED","EATEN","id","predictRandomMovement","target","getGhostTarget","predictPathToTarget","totalDanger","distance","manhattanDistance","maxDangerDistance","DANGER_RADIUS","dangerContribution","Math","min","generateDangerHeatmap","heatmap","Array","length","fill","map","y","x","WALL","recordPlayerMovement","direction","push","PATTERN_THRESHOLD","shift","updatePatternWeights","updateLearningLevel","possibleDirections","getPossibleDirections","bestDirection","lowestDanger","Infinity","nextPosition","getNextPosition","danger","futureDanger","calculateFutureDanger","pacmanPosition","safeDistance","SAFE_DISTANCE","isSafe","every","visited","Set","queue","path","key","has","add","directions","nextPos","isValidPosition","adaptGhostBehavior","baseTarget","predictedDirection","predictPlayerDirection","predictedPosition","interceptTarget","calculateInterceptPoint","velocity","learningWeight","round","currentPos","i","AI_PREDICTION_STEPS","randomDirection","floor","random","findPathAStar","slice","start","goal","openSet","cameFrom","Map","gScore","fScore","set","current","currentIndex","currentKey","nodeKey","get","unshift","splice","neighbor","neighborKey","tentativeGScore","some","pos","getPositionAhead","blinky","find","g","ahead","scatterTarget","Object","keys","total","maxWeight","max","values","consistency","LEARNING_RATE","MAX_LEARNING_LEVEL","weights","entries","weight","ghostPos","targetPos","targetVelocity","dx","dy","sqrt","timeToReach","GHOST_SPEED","steps","step","currentStep","futureGhostPos","estimateGhostPosition","targetPosition","normalizedDx","normalizedDy","pos1","pos2","abs","getLearningLevel","getPlayerPatterns","getPatternWeights"],"sources":["C:/Users/VEDANT/Desktop/Src/Pacman/src/engine/AIEngine.ts"],"sourcesContent":["import { \r\n  Position, \r\n  Direction, \r\n  Ghost, \r\n  PacMan, \r\n  CellType, \r\n  GhostState,\r\n  AIAnalysis,\r\n  GhostType \r\n} from '../types/game.ts';\r\nimport { GAME_CONFIG, AI_CONFIG } from '../config/gameConfig.ts';\r\n\r\n/**\r\n * AI Engine for Pac-Man game\r\n * Implements three core AI features:\r\n * 1. Predictive Path Display - Shows ghost movement predictions\r\n * 2. Danger Zone Heatmap - Real-time danger visualization\r\n * 3. Adaptive Ghost Intelligence - Learning from player patterns\r\n */\r\nexport class AIEngine {\r\n  private playerPatterns: Direction[] = [];\r\n  private patternWeights: { [key in Direction]: number } = {\r\n    [Direction.UP]: 0,\r\n    [Direction.DOWN]: 0,\r\n    [Direction.LEFT]: 0,\r\n    [Direction.RIGHT]: 0,\r\n    [Direction.NONE]: 0\r\n  };\r\n  private learningLevel: number = 0;\r\n\r\n  /**\r\n   * Analyzes current game state and provides AI insights\r\n   */\r\n  analyzeGameState(\r\n    pacman: PacMan,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): AIAnalysis {\r\n    const ghostPredictions = this.predictGhostMovements(ghosts, maze, pacman);\r\n    const dangerLevel = this.calculateDangerLevel(pacman.position, ghosts);\r\n    const suggestedDirection = this.suggestOptimalDirection(pacman, ghosts, maze);\r\n    const safeZones = this.findSafeZones(pacman.position, ghosts, maze);\r\n    const escapeRoutes = this.findEscapeRoutes(pacman.position, ghosts, maze);\r\n\r\n    return {\r\n      dangerLevel,\r\n      suggestedDirection,\r\n      ghostPredictions,\r\n      safeZones,\r\n      escapeRoutes,\r\n      playerTendencies: { ...this.patternWeights }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Predicts ghost movements using A* pathfinding and behavior patterns\r\n   */\r\n  predictGhostMovements(\r\n    ghosts: Ghost[],\r\n    maze: CellType[][],\r\n    pacman: PacMan\r\n  ): { [key in GhostType]: Position[] } {\r\n    const predictions: { [key in GhostType]: Position[] } = {\r\n      [GhostType.BLINKY]: [],\r\n      [GhostType.PINKY]: [],\r\n      [GhostType.INKY]: [],\r\n      [GhostType.CLYDE]: []\r\n    };\r\n\r\n    ghosts.forEach(ghost => {\r\n      if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n        // Frightened ghosts move randomly, harder to predict\r\n        predictions[ghost.id] = this.predictRandomMovement(ghost, maze);\r\n      } else {\r\n        // Use A* pathfinding to predict chase/scatter behavior\r\n        const target = this.getGhostTarget(ghost, pacman, ghosts);\r\n        predictions[ghost.id] = this.predictPathToTarget(ghost, target, maze);\r\n      }\r\n    });\r\n\r\n    return predictions;\r\n  }\r\n\r\n  /**\r\n   * Calculates danger level at given position based on ghost proximity and states\r\n   */\r\n  calculateDangerLevel(position: Position, ghosts: Ghost[]): number {\r\n    let totalDanger = 0;\r\n\r\n    ghosts.forEach(ghost => {\r\n      if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n        return; // No danger from frightened/eaten ghosts\r\n      }\r\n\r\n      const distance = this.manhattanDistance(position, ghost.position);\r\n      const maxDangerDistance = AI_CONFIG.DANGER_RADIUS;\r\n\r\n      if (distance <= maxDangerDistance) {\r\n        // Closer ghosts are more dangerous\r\n        const dangerContribution = (maxDangerDistance - distance) / maxDangerDistance;\r\n        totalDanger += dangerContribution;\r\n      }\r\n    });\r\n\r\n    return Math.min(totalDanger, 1); // Normalize to 0-1\r\n  }\r\n\r\n  /**\r\n   * Generates danger heatmap for the entire maze\r\n   */\r\n  generateDangerHeatmap(ghosts: Ghost[], maze: CellType[][]): number[][] {\r\n    const heatmap: number[][] = Array(maze.length).fill(null)\r\n      .map(() => Array(maze[0].length).fill(0));\r\n\r\n    for (let y = 0; y < maze.length; y++) {\r\n      for (let x = 0; x < maze[0].length; x++) {\r\n        if (maze[y][x] === CellType.WALL) {\r\n          heatmap[y][x] = -1; // Mark walls\r\n          continue;\r\n        }\r\n\r\n        heatmap[y][x] = this.calculateDangerLevel({ x, y }, ghosts);\r\n      }\r\n    }\r\n\r\n    return heatmap;\r\n  }\r\n\r\n  /**\r\n   * Records player movement patterns for adaptive AI\r\n   */\r\n  recordPlayerMovement(direction: Direction): void {\r\n    this.playerPatterns.push(direction);\r\n\r\n    // Keep only recent patterns\r\n    if (this.playerPatterns.length > AI_CONFIG.PATTERN_THRESHOLD) {\r\n      this.playerPatterns.shift();\r\n    }\r\n\r\n    // Update pattern weights\r\n    this.updatePatternWeights();\r\n    this.updateLearningLevel();\r\n  }\r\n\r\n  /**\r\n   * Suggests optimal direction based on danger analysis and escape routes\r\n   */\r\n  suggestOptimalDirection(\r\n    pacman: PacMan,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): Direction {\r\n    const possibleDirections = this.getPossibleDirections(pacman.position, maze);\r\n    let bestDirection = Direction.NONE;\r\n    let lowestDanger = Infinity;\r\n\r\n    possibleDirections.forEach(direction => {\r\n      const nextPosition = this.getNextPosition(pacman.position, direction);\r\n      const danger = this.calculateDangerLevel(nextPosition, ghosts);\r\n      \r\n      // Consider future danger by looking ahead\r\n      const futureDanger = this.calculateFutureDanger(nextPosition, ghosts, maze, 3);\r\n      const totalDanger = danger + (futureDanger * 0.5);\r\n\r\n      if (totalDanger < lowestDanger) {\r\n        lowestDanger = totalDanger;\r\n        bestDirection = direction;\r\n      }\r\n    });\r\n\r\n    return bestDirection;\r\n  }\r\n\r\n  /**\r\n   * Finds safe zones where player can temporarily hide\r\n   */\r\n  findSafeZones(\r\n    pacmanPosition: Position,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const safeZones: Position[] = [];\r\n    const safeDistance = AI_CONFIG.SAFE_DISTANCE;\r\n\r\n    for (let y = 0; y < maze.length; y++) {\r\n      for (let x = 0; x < maze[0].length; x++) {\r\n        if (maze[y][x] === CellType.WALL) continue;\r\n\r\n        const position = { x, y };\r\n        const isSafe = ghosts.every(ghost => {\r\n          if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n            return true;\r\n          }\r\n          return this.manhattanDistance(position, ghost.position) >= safeDistance;\r\n        });\r\n\r\n        if (isSafe && this.manhattanDistance(position, pacmanPosition) <= 8) {\r\n          safeZones.push(position);\r\n        }\r\n      }\r\n    }\r\n\r\n    return safeZones;\r\n  }\r\n\r\n  /**\r\n   * Finds escape routes when surrounded by ghosts\r\n   */\r\n  findEscapeRoutes(\r\n    pacmanPosition: Position,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const escapeRoutes: Position[] = [];\r\n    const visited = new Set<string>();\r\n    const queue: { position: Position; path: Position[] }[] = [\r\n      { position: pacmanPosition, path: [] }\r\n    ];\r\n\r\n    while (queue.length > 0) {\r\n      const { position, path } = queue.shift()!;\r\n      const key = `${position.x},${position.y}`;\r\n\r\n      if (visited.has(key) || path.length > 6) continue;\r\n      visited.add(key);\r\n\r\n      // Check if this position is safe\r\n      const danger = this.calculateDangerLevel(position, ghosts);\r\n      if (danger < 0.3 && path.length > 2) {\r\n        escapeRoutes.push(...path);\r\n        continue;\r\n      }\r\n\r\n      // Explore adjacent positions\r\n      const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];\r\n      directions.forEach(direction => {\r\n        const nextPos = this.getNextPosition(position, direction);\r\n        if (this.isValidPosition(nextPos, maze)) {\r\n          queue.push({\r\n            position: nextPos,\r\n            path: [...path, nextPos]\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    return escapeRoutes;\r\n  }\r\n\r\n  /**\r\n   * Adapts ghost behavior based on learned player patterns\r\n   */\r\n  adaptGhostBehavior(ghost: Ghost, pacman: PacMan, ghosts: Ghost[]): Position {\r\n    const baseTarget = this.getGhostTarget(ghost, pacman, ghosts);\r\n    \r\n    if (this.learningLevel < 20) {\r\n      return baseTarget; // Not enough learning yet\r\n    }\r\n\r\n    // Predict where player is likely to go based on patterns\r\n    const predictedDirection = this.predictPlayerDirection();\r\n    const predictedPosition = this.getNextPosition(pacman.position, predictedDirection);\r\n\r\n    // Adjust ghost target to intercept predicted path\r\n    const interceptTarget = this.calculateInterceptPoint(\r\n      ghost.position,\r\n      predictedPosition,\r\n      pacman.velocity\r\n    );\r\n\r\n    // Blend original target with intercept target based on learning level\r\n    const learningWeight = Math.min(this.learningLevel / 100, 0.7);\r\n    \r\n    return {\r\n      x: Math.round(baseTarget.x * (1 - learningWeight) + interceptTarget.x * learningWeight),\r\n      y: Math.round(baseTarget.y * (1 - learningWeight) + interceptTarget.y * learningWeight)\r\n    };\r\n  }\r\n\r\n  // Private helper methods\r\n\r\n  private predictRandomMovement(ghost: Ghost, maze: CellType[][]): Position[] {\r\n    const predictions: Position[] = [];\r\n    let currentPos = { ...ghost.position };\r\n\r\n    for (let i = 0; i < GAME_CONFIG.AI_PREDICTION_STEPS; i++) {\r\n      const possibleDirections = this.getPossibleDirections(currentPos, maze);\r\n      const randomDirection = possibleDirections[\r\n        Math.floor(Math.random() * possibleDirections.length)\r\n      ];\r\n      currentPos = this.getNextPosition(currentPos, randomDirection);\r\n      predictions.push({ ...currentPos });\r\n    }\r\n\r\n    return predictions;\r\n  }\r\n\r\n  private predictPathToTarget(\r\n    ghost: Ghost,\r\n    target: Position,\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const path = this.findPathAStar(ghost.position, target, maze);\r\n    return path.slice(1, GAME_CONFIG.AI_PREDICTION_STEPS + 1);\r\n  }\r\n\r\n  private findPathAStar(\r\n    start: Position,\r\n    goal: Position,\r\n    maze: CellType[][]\r\n  ): Position[] {\r\n    const openSet = [start];\r\n    const cameFrom = new Map<string, Position>();\r\n    const gScore = new Map<string, number>();\r\n    const fScore = new Map<string, number>();\r\n\r\n    gScore.set(`${start.x},${start.y}`, 0);\r\n    fScore.set(`${start.x},${start.y}`, this.manhattanDistance(start, goal));\r\n\r\n    while (openSet.length > 0) {\r\n      // Find node with lowest fScore\r\n      let current = openSet[0];\r\n      let currentIndex = 0;\r\n      \r\n      for (let i = 1; i < openSet.length; i++) {\r\n        const currentKey = `${current.x},${current.y}`;\r\n        const nodeKey = `${openSet[i].x},${openSet[i].y}`;\r\n        if ((fScore.get(nodeKey) || Infinity) < (fScore.get(currentKey) || Infinity)) {\r\n          current = openSet[i];\r\n          currentIndex = i;\r\n        }\r\n      }\r\n\r\n      if (current.x === goal.x && current.y === goal.y) {\r\n        // Reconstruct path\r\n        const path = [current];\r\n        let currentKey = `${current.x},${current.y}`;\r\n        \r\n        while (cameFrom.has(currentKey)) {\r\n          current = cameFrom.get(currentKey)!;\r\n          path.unshift(current);\r\n          currentKey = `${current.x},${current.y}`;\r\n        }\r\n        \r\n        return path;\r\n      }\r\n\r\n      openSet.splice(currentIndex, 1);\r\n      \r\n      // Check neighbors\r\n      const directions = [Direction.UP, Direction.DOWN, Direction.LEFT, Direction.RIGHT];\r\n      directions.forEach(direction => {\r\n        const neighbor = this.getNextPosition(current, direction);\r\n        \r\n        if (!this.isValidPosition(neighbor, maze)) return;\r\n\r\n        const neighborKey = `${neighbor.x},${neighbor.y}`;\r\n        const tentativeGScore = (gScore.get(`${current.x},${current.y}`) || 0) + 1;\r\n\r\n        if (tentativeGScore < (gScore.get(neighborKey) || Infinity)) {\r\n          cameFrom.set(neighborKey, current);\r\n          gScore.set(neighborKey, tentativeGScore);\r\n          fScore.set(neighborKey, tentativeGScore + this.manhattanDistance(neighbor, goal));\r\n\r\n          if (!openSet.some(pos => pos.x === neighbor.x && pos.y === neighbor.y)) {\r\n            openSet.push(neighbor);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    return []; // No path found\r\n  }\r\n\r\n  private getGhostTarget(ghost: Ghost, pacman: PacMan, ghosts: Ghost[]): Position {\r\n    switch (ghost.id) {\r\n      case GhostType.BLINKY:\r\n        // Blinky targets Pac-Man directly\r\n        return pacman.position;\r\n        \r\n      case GhostType.PINKY:\r\n        // Pinky targets 4 cells ahead of Pac-Man\r\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\r\n        \r\n      case GhostType.INKY:\r\n        // Inky uses complex targeting involving Blinky\r\n        const blinky = ghosts.find(g => g.id === GhostType.BLINKY);\r\n        if (blinky) {\r\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\r\n          return {\r\n            x: ahead.x + (ahead.x - blinky.position.x),\r\n            y: ahead.y + (ahead.y - blinky.position.y)\r\n          };\r\n        }\r\n        return pacman.position;\r\n        \r\n      case GhostType.CLYDE:\r\n        // Clyde targets Pac-Man when far, scatters when close\r\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\r\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\r\n        \r\n      default:\r\n        return pacman.position;\r\n    }\r\n  }\r\n\r\n  private updatePatternWeights(): void {\r\n    // Reset weights\r\n    Object.keys(this.patternWeights).forEach(key => {\r\n      this.patternWeights[key as Direction] = 0;\r\n    });\r\n\r\n    // Calculate frequency of each direction\r\n    this.playerPatterns.forEach(direction => {\r\n      this.patternWeights[direction]++;\r\n    });\r\n\r\n    // Normalize to percentages\r\n    const total = this.playerPatterns.length;\r\n    Object.keys(this.patternWeights).forEach(key => {\r\n      this.patternWeights[key as Direction] /= total;\r\n    });\r\n  }\r\n\r\n  private updateLearningLevel(): void {\r\n    // Learning level increases with pattern consistency\r\n    const maxWeight = Math.max(...Object.values(this.patternWeights));\r\n    const consistency = maxWeight - 0.25; // 0.25 is random chance\r\n    \r\n    if (consistency > 0) {\r\n      this.learningLevel = Math.min(\r\n        this.learningLevel + (consistency * AI_CONFIG.LEARNING_RATE),\r\n        AI_CONFIG.MAX_LEARNING_LEVEL\r\n      );\r\n    }\r\n  }\r\n\r\n  private predictPlayerDirection(): Direction {\r\n    const weights = this.patternWeights;\r\n    let maxWeight = 0;\r\n    let predictedDirection = Direction.NONE;\r\n\r\n    Object.entries(weights).forEach(([direction, weight]) => {\r\n      if (weight > maxWeight) {\r\n        maxWeight = weight;\r\n        predictedDirection = direction as Direction;\r\n      }\r\n    });\r\n\r\n    return predictedDirection;\r\n  }\r\n\r\n  private calculateInterceptPoint(\r\n    ghostPos: Position,\r\n    targetPos: Position,\r\n    targetVelocity: { dx: number; dy: number }\r\n  ): Position {\r\n    // Simple interception calculation\r\n    const dx = targetPos.x - ghostPos.x;\r\n    const dy = targetPos.y - ghostPos.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    const timeToReach = distance / GAME_CONFIG.GHOST_SPEED;\r\n\r\n    return {\r\n      x: Math.round(targetPos.x + targetVelocity.dx * timeToReach),\r\n      y: Math.round(targetPos.y + targetVelocity.dy * timeToReach)\r\n    };\r\n  }\r\n\r\n  private calculateFutureDanger(\r\n    position: Position,\r\n    ghosts: Ghost[],\r\n    maze: CellType[][],\r\n    steps: number\r\n  ): number {\r\n    let totalDanger = 0;\r\n\r\n    for (let step = 1; step <= steps; step++) {\r\n      const currentStep = step; // Capture step value to avoid closure issue\r\n      // eslint-disable-next-line no-loop-func\r\n      ghosts.forEach(ghost => {\r\n        if (ghost.state === GhostState.FRIGHTENED || ghost.state === GhostState.EATEN) {\r\n          return;\r\n        }\r\n\r\n        // Estimate ghost position after 'step' moves\r\n        const futureGhostPos = this.estimateGhostPosition(ghost, currentStep);\r\n        const distance = this.manhattanDistance(position, futureGhostPos);\r\n        \r\n        if (distance <= AI_CONFIG.DANGER_RADIUS) {\r\n          totalDanger += (AI_CONFIG.DANGER_RADIUS - distance) / AI_CONFIG.DANGER_RADIUS / currentStep;\r\n        }\r\n      });\r\n    }\r\n\r\n    return totalDanger;\r\n  }\r\n\r\n  private estimateGhostPosition(ghost: Ghost, steps: number): Position {\r\n    // Simple estimation - ghost moves toward its current target\r\n    const dx = ghost.targetPosition.x - ghost.position.x;\r\n    const dy = ghost.targetPosition.y - ghost.position.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n    if (distance === 0) return ghost.position;\r\n\r\n    const normalizedDx = dx / distance;\r\n    const normalizedDy = dy / distance;\r\n\r\n    return {\r\n      x: Math.round(ghost.position.x + normalizedDx * GAME_CONFIG.GHOST_SPEED * steps),\r\n      y: Math.round(ghost.position.y + normalizedDy * GAME_CONFIG.GHOST_SPEED * steps)\r\n    };\r\n  }\r\n\r\n  private getPossibleDirections(position: Position, maze: CellType[][]): Direction[] {\r\n    const directions: Direction[] = [];\r\n    \r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.UP), maze)) {\r\n      directions.push(Direction.UP);\r\n    }\r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.DOWN), maze)) {\r\n      directions.push(Direction.DOWN);\r\n    }\r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.LEFT), maze)) {\r\n      directions.push(Direction.LEFT);\r\n    }\r\n    if (this.isValidPosition(this.getNextPosition(position, Direction.RIGHT), maze)) {\r\n      directions.push(Direction.RIGHT);\r\n    }\r\n\r\n    return directions;\r\n  }\r\n\r\n  private getNextPosition(position: Position, direction: Direction): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - 1 };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + 1 };\r\n      case Direction.LEFT:\r\n        return { x: position.x - 1, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + 1, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getPositionAhead(position: Position, direction: Direction, distance: number): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - distance };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + distance };\r\n      case Direction.LEFT:\r\n        return { x: position.x - distance, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + distance, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private isValidPosition(position: Position, maze: CellType[][]): boolean {\r\n    if (position.y < 0 || position.y >= maze.length) return false;\r\n    if (position.x < 0 || position.x >= maze[0].length) return false;\r\n    return maze[position.y][position.x] !== CellType.WALL;\r\n  }\r\n\r\n  private manhattanDistance(pos1: Position, pos2: Position): number {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n  }\r\n\r\n  // Getters for external access\r\n  getLearningLevel(): number {\r\n    return this.learningLevel;\r\n  }\r\n\r\n  getPlayerPatterns(): Direction[] {\r\n    return [...this.playerPatterns];\r\n  }\r\n\r\n  getPatternWeights(): { [key in Direction]: number } {\r\n    return { ...this.patternWeights };\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}