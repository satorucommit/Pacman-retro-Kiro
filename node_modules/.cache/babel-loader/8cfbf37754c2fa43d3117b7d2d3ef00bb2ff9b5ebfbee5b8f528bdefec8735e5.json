{"ast":null,"code":"import { Direction, CellType, GhostState, GhostType } from '../types/game.ts';\nimport { GAME_CONFIG, MAZE_LAYOUT, GHOST_CONFIG, PACMAN_START_POSITION } from '../config/gameConfig.ts';\nimport { AIEngine } from './AIEngine.ts';\n\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\nexport class GameEngine {\n  constructor() {\n    this.aiEngine = void 0;\n    this.gameState = void 0;\n    this.lastUpdateTime = 0;\n    this.frameCount = 0;\n    this.aiEngine = new AIEngine();\n    this.gameState = this.initializeGameState();\n  }\n\n  /**\r\n   * Initialize the game state with default values\r\n   */\n  initializeGameState() {\n    const maze = MAZE_LAYOUT.map(row => [...row]);\n    const pelletsRemaining = this.countPellets(maze);\n    return {\n      pacman: this.createPacMan(),\n      ghosts: this.createGhosts(),\n      maze,\n      score: 0,\n      highScore: parseInt(localStorage.getItem('pacman-highscore') || '0'),\n      lives: 3,\n      level: 1,\n      pelletsRemaining,\n      powerPelletActive: false,\n      powerPelletTimer: 0,\n      gameStatus: 'READY',\n      ghostEatenCount: 0,\n      fruitSpawned: false,\n      fruitPosition: null,\n      fruitScore: 0,\n      aiLearningLevel: 0,\n      showAIFeatures: true,\n      dangerMap: [],\n      playerPatterns: [],\n      screenShake: false,\n      vhsGlitch: false\n    };\n  }\n\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\n  createPacMan() {\n    return {\n      position: {\n        ...PACMAN_START_POSITION\n      },\n      velocity: {\n        dx: 0,\n        dy: 0\n      },\n      direction: Direction.NONE,\n      nextDirection: Direction.NONE,\n      animationFrame: 0,\n      isDead: false,\n      mouthOpen: true\n    };\n  }\n\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\n  createGhosts() {\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\n      id: type,\n      position: {\n        ...config.startPosition\n      },\n      velocity: {\n        dx: 0,\n        dy: 0\n      },\n      direction: Direction.UP,\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\n      color: config.color,\n      targetPosition: {\n        ...config.scatterTarget\n      },\n      scatterTarget: {\n        ...config.scatterTarget\n      },\n      houseTimer: type === 'BLINKY' ? 0 : 60 + Object.keys(GHOST_CONFIG).indexOf(type) * 30,\n      frightenedTimer: 0,\n      isFlashing: false,\n      lastDirection: Direction.UP,\n      pathPrediction: []\n    }));\n  }\n\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\n  update(currentTime, inputDirection) {\n    // const deltaTime = currentTime - this.lastUpdateTime;\n    this.lastUpdateTime = currentTime;\n    this.frameCount++;\n    if (this.gameState.gameStatus !== 'PLAYING') {\n      return this.gameState;\n    }\n\n    // Update Pac-Man\n    this.updatePacMan(inputDirection);\n\n    // Update ghosts\n    this.updateGhosts();\n\n    // Check collisions\n    this.checkCollisions();\n\n    // Update power pellet timer\n    this.updatePowerPelletTimer();\n\n    // Update AI analysis\n    this.updateAIAnalysis();\n\n    // Check win/lose conditions\n    this.checkGameConditions();\n\n    // Update visual effects\n    this.updateVisualEffects();\n\n    // Spawn fruit occasionally\n    this.updateFruitSpawning();\n    return this.gameState;\n  }\n\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\n  updatePacMan(inputDirection) {\n    const pacman = this.gameState.pacman;\n\n    // Handle direction changes\n    if (inputDirection !== Direction.NONE) {\n      pacman.nextDirection = inputDirection;\n\n      // Record movement for AI learning\n      this.aiEngine.recordPlayerMovement(inputDirection);\n    }\n\n    // Try to change direction if possible\n    if (pacman.nextDirection !== pacman.direction) {\n      const nextPos = this.getNextPosition(pacman.position, pacman.nextDirection);\n      if (this.isValidMove(nextPos)) {\n        pacman.direction = pacman.nextDirection;\n        this.setVelocity(pacman, pacman.direction);\n      }\n    }\n\n    // Move Pac-Man\n    if (pacman.direction !== Direction.NONE) {\n      const nextPos = {\n        x: pacman.position.x + pacman.velocity.dx,\n        y: pacman.position.y + pacman.velocity.dy\n      };\n\n      // Handle tunnel wraparound\n      if (nextPos.x < 0) {\n        nextPos.x = GAME_CONFIG.MAZE_WIDTH - 1;\n      } else if (nextPos.x >= GAME_CONFIG.MAZE_WIDTH) {\n        nextPos.x = 0;\n      }\n\n      // Check if move is valid\n      if (this.isValidMove(nextPos)) {\n        pacman.position = nextPos;\n      } else {\n        // Stop if hitting wall\n        pacman.direction = Direction.NONE;\n        pacman.velocity = {\n          dx: 0,\n          dy: 0\n        };\n      }\n    }\n\n    // Update animation\n    if (this.frameCount % 8 === 0) {\n      pacman.mouthOpen = !pacman.mouthOpen;\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\n    }\n  }\n\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\n  updateGhosts() {\n    this.gameState.ghosts.forEach(ghost => {\n      this.updateGhostState(ghost);\n      this.updateGhostMovement(ghost);\n      this.updateGhostAnimation(ghost);\n    });\n  }\n\n  /**\r\n   * Update individual ghost state and target\r\n   */\n  updateGhostState(ghost) {\n    // Handle house timer\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\n      ghost.houseTimer--;\n      if (ghost.houseTimer <= 0) {\n        ghost.state = GhostState.CHASE;\n      }\n      return;\n    }\n\n    // Handle frightened state\n    if (ghost.state === GhostState.FRIGHTENED) {\n      ghost.frightenedTimer--;\n\n      // Start flashing when timer is low\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\n      }\n      if (ghost.frightenedTimer <= 0) {\n        ghost.state = GhostState.CHASE;\n        ghost.isFlashing = false;\n      }\n      return;\n    }\n\n    // Handle eaten state\n    if (ghost.state === GhostState.EATEN) {\n      // Return to house\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\n        ghost.state = GhostState.CHASE;\n      }\n      ghost.targetPosition = housePos;\n      return;\n    }\n\n    // Normal chase/scatter behavior with AI adaptation\n    // const baseTarget = this.getGhostTarget(ghost);\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(ghost, this.gameState.pacman, this.gameState.ghosts);\n\n    // Alternate between chase and scatter modes\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\n  }\n\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\n  updateGhostMovement(ghost) {\n    if (ghost.state === GhostState.IN_HOUSE) {\n      // Simple up-down movement in house\n      if (this.frameCount % 60 < 30) {\n        ghost.direction = Direction.UP;\n      } else {\n        ghost.direction = Direction.DOWN;\n      }\n      this.setGhostVelocity(ghost);\n      return;\n    }\n\n    // Get possible directions (can't reverse unless frightened)\n    const possibleDirections = this.getPossibleDirections(ghost.position).filter(dir => {\n      if (ghost.state === GhostState.FRIGHTENED) return true;\n      return this.getOppositeDirection(dir) !== ghost.lastDirection;\n    });\n    if (possibleDirections.length === 0) return;\n\n    // Choose direction based on target\n    let bestDirection = possibleDirections[0];\n    let shortestDistance = Infinity;\n    if (ghost.state === GhostState.FRIGHTENED) {\n      // Random movement when frightened\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\n    } else {\n      // Move toward target\n      possibleDirections.forEach(direction => {\n        const nextPos = this.getNextPosition(ghost.position, direction);\n        const distance = this.manhattanDistance(nextPos, ghost.targetPosition);\n        if (distance < shortestDistance) {\n          shortestDistance = distance;\n          bestDirection = direction;\n        }\n      });\n    }\n    ghost.lastDirection = ghost.direction;\n    ghost.direction = bestDirection;\n    this.setGhostVelocity(ghost);\n\n    // Move ghost\n    const nextPos = {\n      x: ghost.position.x + ghost.velocity.dx,\n      y: ghost.position.y + ghost.velocity.dy\n    };\n\n    // Handle tunnel wraparound\n    if (nextPos.x < 0) {\n      nextPos.x = GAME_CONFIG.MAZE_WIDTH - 1;\n    } else if (nextPos.x >= GAME_CONFIG.MAZE_WIDTH) {\n      nextPos.x = 0;\n    }\n    if (this.isValidMove(nextPos)) {\n      ghost.position = nextPos;\n    }\n  }\n\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\n  updateGhostAnimation(ghost) {\n    // Update path prediction for AI visualization\n    if (this.frameCount % 30 === 0) {\n      // Update every half second\n      const predictions = this.aiEngine.predictGhostMovements([ghost], this.gameState.maze, this.gameState.pacman);\n      ghost.pathPrediction = predictions[ghost.id] || [];\n    }\n  }\n\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\n  checkCollisions() {\n    const pacmanPos = this.gameState.pacman.position;\n    const cellType = this.gameState.maze[pacmanPos.y][pacmanPos.x];\n\n    // Collect pellets\n    if (cellType === CellType.PELLET) {\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\n      this.gameState.pelletsRemaining--;\n      this.playSound('CHOMP');\n    }\n\n    // Collect power pellets\n    if (cellType === CellType.POWER_PELLET) {\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\n      this.gameState.pelletsRemaining--;\n      this.activatePowerPellet();\n      this.playSound('POWER_PELLET');\n    }\n\n    // Collect fruit\n    if (this.gameState.fruitPosition && pacmanPos.x === this.gameState.fruitPosition.x && pacmanPos.y === this.gameState.fruitPosition.y) {\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\n      this.gameState.score += fruitPoints;\n      this.gameState.fruitScore = fruitPoints;\n      this.gameState.fruitPosition = null;\n      this.gameState.fruitSpawned = false;\n      this.playSound('FRUIT');\n    }\n\n    // Check ghost collisions\n    this.gameState.ghosts.forEach(ghost => {\n      if (this.manhattanDistance(pacmanPos, ghost.position) < 1) {\n        if (ghost.state === GhostState.FRIGHTENED) {\n          // Eat ghost\n          ghost.state = GhostState.EATEN;\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\n          this.gameState.score += points;\n          this.gameState.ghostEatenCount++;\n          this.gameState.screenShake = true;\n          this.playSound('GHOST_EATEN');\n        } else if (ghost.state !== GhostState.EATEN) {\n          // Pac-Man dies\n          this.gameState.pacman.isDead = true;\n          this.gameState.lives--;\n          this.gameState.screenShake = true;\n          this.playSound('DEATH');\n          if (this.gameState.lives <= 0) {\n            this.gameState.gameStatus = 'GAME_OVER';\n          } else {\n            // Reset positions\n            setTimeout(() => this.resetPositions(), 2000);\n          }\n        }\n      }\n    });\n  }\n\n  /**\r\n   * Activate power pellet effect\r\n   */\n  activatePowerPellet() {\n    this.gameState.powerPelletActive = true;\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\n    this.gameState.ghostEatenCount = 0;\n\n    // Make ghosts frightened\n    this.gameState.ghosts.forEach(ghost => {\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\n        ghost.state = GhostState.FRIGHTENED;\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\n        ghost.isFlashing = false;\n        // Reverse direction\n        ghost.direction = this.getOppositeDirection(ghost.direction);\n      }\n    });\n  }\n\n  /**\r\n   * Update power pellet timer\r\n   */\n  updatePowerPelletTimer() {\n    if (this.gameState.powerPelletActive) {\n      this.gameState.powerPelletTimer--;\n      if (this.gameState.powerPelletTimer <= 0) {\n        this.gameState.powerPelletActive = false;\n      }\n    }\n  }\n\n  /**\r\n   * Update AI analysis and danger map\r\n   */\n  updateAIAnalysis() {\n    if (this.frameCount % 10 === 0) {\n      // Update every 6th of a second\n      // const analysis = this.aiEngine.analyzeGameState(\n      //   this.gameState.pacman,\n      //   this.gameState.ghosts,\n      //   this.gameState.maze\n      // );\n\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(this.gameState.ghosts, this.gameState.maze);\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\n    }\n  }\n\n  /**\r\n   * Check win/lose conditions\r\n   */\n  checkGameConditions() {\n    // Check if all pellets collected\n    if (this.gameState.pelletsRemaining <= 0) {\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\n      this.gameState.level++;\n\n      // Reset maze and positions for next level\n      setTimeout(() => {\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\n        this.resetPositions();\n        this.gameState.gameStatus = 'READY';\n      }, 2000);\n    }\n\n    // Update high score\n    if (this.gameState.score > this.gameState.highScore) {\n      this.gameState.highScore = this.gameState.score;\n      localStorage.setItem('pacman-highscore', this.gameState.score.toString());\n    }\n  }\n\n  /**\r\n   * Update visual effects\r\n   */\n  updateVisualEffects() {\n    // Reset screen shake\n    if (this.gameState.screenShake) {\n      setTimeout(() => {\n        this.gameState.screenShake = false;\n      }, 200);\n    }\n\n    // Random VHS glitch effect\n    if (Math.random() < 0.001) {\n      this.gameState.vhsGlitch = true;\n      setTimeout(() => {\n        this.gameState.vhsGlitch = false;\n      }, 100);\n    }\n  }\n\n  /**\r\n   * Update fruit spawning logic\r\n   */\n  updateFruitSpawning() {\n    if (!this.gameState.fruitSpawned && this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\n      // Spawn fruit when 70% of pellets are eaten\n      this.gameState.fruitSpawned = true;\n      this.gameState.fruitPosition = {\n        x: 9,\n        y: 15\n      }; // Center of maze\n\n      // Remove fruit after 10 seconds\n      setTimeout(() => {\n        this.gameState.fruitPosition = null;\n        this.gameState.fruitSpawned = false;\n      }, 10000);\n    }\n  }\n\n  // Helper methods\n\n  getGhostTarget(ghost) {\n    const pacman = this.gameState.pacman;\n    switch (ghost.id) {\n      case GhostType.BLINKY:\n        return pacman.position;\n      case GhostType.PINKY:\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\n      case GhostType.INKY:\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\n        if (blinky) {\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\n          return {\n            x: ahead.x + (ahead.x - blinky.position.x),\n            y: ahead.y + (ahead.y - blinky.position.y)\n          };\n        }\n        return pacman.position;\n      case GhostType.CLYDE:\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\n      default:\n        return pacman.position;\n    }\n  }\n  getNextPosition(position, direction) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: position.y - 1\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: position.y + 1\n        };\n      case Direction.LEFT:\n        return {\n          x: position.x - 1,\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: position.x + 1,\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getPositionAhead(position, direction, distance) {\n    switch (direction) {\n      case Direction.UP:\n        return {\n          x: position.x,\n          y: Math.max(0, position.y - distance)\n        };\n      case Direction.DOWN:\n        return {\n          x: position.x,\n          y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance)\n        };\n      case Direction.LEFT:\n        return {\n          x: Math.max(0, position.x - distance),\n          y: position.y\n        };\n      case Direction.RIGHT:\n        return {\n          x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance),\n          y: position.y\n        };\n      default:\n        return position;\n    }\n  }\n  getOppositeDirection(direction) {\n    switch (direction) {\n      case Direction.UP:\n        return Direction.DOWN;\n      case Direction.DOWN:\n        return Direction.UP;\n      case Direction.LEFT:\n        return Direction.RIGHT;\n      case Direction.RIGHT:\n        return Direction.LEFT;\n      default:\n        return Direction.NONE;\n    }\n  }\n  getPossibleDirections(position) {\n    const directions = [];\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\n      directions.push(Direction.UP);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\n      directions.push(Direction.DOWN);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\n      directions.push(Direction.LEFT);\n    }\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\n      directions.push(Direction.RIGHT);\n    }\n    return directions;\n  }\n  isValidMove(position) {\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\n    const cellType = this.gameState.maze[position.y][position.x];\n    return cellType !== CellType.WALL;\n  }\n  setVelocity(entity, direction) {\n    const speed = GAME_CONFIG.PACMAN_SPEED;\n    switch (direction) {\n      case Direction.UP:\n        entity.velocity = {\n          dx: 0,\n          dy: -speed\n        };\n        break;\n      case Direction.DOWN:\n        entity.velocity = {\n          dx: 0,\n          dy: speed\n        };\n        break;\n      case Direction.LEFT:\n        entity.velocity = {\n          dx: -speed,\n          dy: 0\n        };\n        break;\n      case Direction.RIGHT:\n        entity.velocity = {\n          dx: speed,\n          dy: 0\n        };\n        break;\n      default:\n        entity.velocity = {\n          dx: 0,\n          dy: 0\n        };\n    }\n  }\n  setGhostVelocity(ghost) {\n    let speed = GAME_CONFIG.GHOST_SPEED;\n    if (ghost.state === GhostState.FRIGHTENED) {\n      speed = GAME_CONFIG.FRIGHTENED_SPEED;\n    } else if (ghost.state === GhostState.EATEN) {\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5; // Faster when returning to house\n    }\n    switch (ghost.direction) {\n      case Direction.UP:\n        ghost.velocity = {\n          dx: 0,\n          dy: -speed\n        };\n        break;\n      case Direction.DOWN:\n        ghost.velocity = {\n          dx: 0,\n          dy: speed\n        };\n        break;\n      case Direction.LEFT:\n        ghost.velocity = {\n          dx: -speed,\n          dy: 0\n        };\n        break;\n      case Direction.RIGHT:\n        ghost.velocity = {\n          dx: speed,\n          dy: 0\n        };\n        break;\n      default:\n        ghost.velocity = {\n          dx: 0,\n          dy: 0\n        };\n    }\n  }\n  manhattanDistance(pos1, pos2) {\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\n  }\n  countPellets(maze) {\n    let count = 0;\n    maze.forEach(row => {\n      row.forEach(cell => {\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\n          count++;\n        }\n      });\n    });\n    return count;\n  }\n  resetPositions() {\n    this.gameState.pacman.position = {\n      ...PACMAN_START_POSITION\n    };\n    this.gameState.pacman.direction = Direction.NONE;\n    this.gameState.pacman.velocity = {\n      dx: 0,\n      dy: 0\n    };\n    this.gameState.pacman.isDead = false;\n    this.gameState.ghosts.forEach(ghost => {\n      ghost.position = {\n        ...GHOST_CONFIG[ghost.id].startPosition\n      };\n      ghost.direction = Direction.UP;\n      ghost.velocity = {\n        dx: 0,\n        dy: 0\n      };\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\n    });\n    this.gameState.powerPelletActive = false;\n    this.gameState.powerPelletTimer = 0;\n    this.gameState.gameStatus = 'READY';\n  }\n  playSound(soundName) {\n    // Sound implementation would go here\n    // For now, just log the sound that would be played\n    console.log(`Playing sound: ${soundName}`);\n  }\n\n  // Public methods for external access\n\n  getGameState() {\n    return this.gameState;\n  }\n  startGame() {\n    this.gameState.gameStatus = 'PLAYING';\n  }\n  pauseGame() {\n    this.gameState.gameStatus = 'PAUSED';\n  }\n  resumeGame() {\n    this.gameState.gameStatus = 'PLAYING';\n  }\n  restartGame() {\n    this.gameState = this.initializeGameState();\n  }\n  toggleAIFeatures() {\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\n  }\n}","map":{"version":3,"names":["Direction","CellType","GhostState","GhostType","GAME_CONFIG","MAZE_LAYOUT","GHOST_CONFIG","PACMAN_START_POSITION","AIEngine","GameEngine","constructor","aiEngine","gameState","lastUpdateTime","frameCount","initializeGameState","maze","map","row","pelletsRemaining","countPellets","pacman","createPacMan","ghosts","createGhosts","score","highScore","parseInt","localStorage","getItem","lives","level","powerPelletActive","powerPelletTimer","gameStatus","ghostEatenCount","fruitSpawned","fruitPosition","fruitScore","aiLearningLevel","showAIFeatures","dangerMap","playerPatterns","screenShake","vhsGlitch","position","velocity","dx","dy","direction","NONE","nextDirection","animationFrame","isDead","mouthOpen","Object","entries","type","config","id","startPosition","UP","state","CHASE","IN_HOUSE","color","targetPosition","scatterTarget","houseTimer","keys","indexOf","frightenedTimer","isFlashing","lastDirection","pathPrediction","update","currentTime","inputDirection","updatePacMan","updateGhosts","checkCollisions","updatePowerPelletTimer","updateAIAnalysis","checkGameConditions","updateVisualEffects","updateFruitSpawning","recordPlayerMovement","nextPos","getNextPosition","isValidMove","setVelocity","x","y","MAZE_WIDTH","forEach","ghost","updateGhostState","updateGhostMovement","updateGhostAnimation","FRIGHTENED","GHOST_FLASH_DURATION","Math","floor","EATEN","housePos","adaptGhostBehavior","modeTime","SCATTER","DOWN","setGhostVelocity","possibleDirections","getPossibleDirections","filter","dir","getOppositeDirection","length","bestDirection","shortestDistance","Infinity","random","distance","manhattanDistance","predictions","predictGhostMovements","pacmanPos","cellType","PELLET","EMPTY","POINTS_PELLET","playSound","POWER_PELLET","POINTS_POWER_PELLET","activatePowerPellet","fruitPoints","POINTS_FRUIT","min","points","POINTS_GHOST_BASE","pow","setTimeout","resetPositions","POWER_PELLET_DURATION","generateDangerHeatmap","getLearningLevel","getPlayerPatterns","setItem","toString","getGhostTarget","BLINKY","PINKY","getPositionAhead","INKY","blinky","find","g","ahead","CLYDE","LEFT","RIGHT","max","MAZE_HEIGHT","directions","push","WALL","entity","speed","PACMAN_SPEED","GHOST_SPEED","FRIGHTENED_SPEED","pos1","pos2","abs","count","cell","soundName","console","log","getGameState","startGame","pauseGame","resumeGame","restartGame","toggleAIFeatures"],"sources":["C:/Users/VEDANT/Desktop/Src/Pacman/src/engine/GameEngine.ts"],"sourcesContent":["import {\r\n  GameState,\r\n  PacMan,\r\n  Ghost,\r\n  Position,\r\n  Direction,\r\n  CellType,\r\n  GhostState,\r\n  GhostType\r\n} from '../types/game.ts';\r\nimport {\r\n  GAME_CONFIG,\r\n  MAZE_LAYOUT,\r\n  GHOST_CONFIG,\r\n  PACMAN_START_POSITION\r\n} from '../config/gameConfig.ts';\r\nimport { AIEngine } from './AIEngine.ts';\r\n\r\n/**\r\n * Core game engine handling all game logic, physics, and state management\r\n */\r\nexport class GameEngine {\r\n  private aiEngine: AIEngine;\r\n  private gameState: GameState;\r\n  private lastUpdateTime: number = 0;\r\n  private frameCount: number = 0;\r\n\r\n  constructor() {\r\n    this.aiEngine = new AIEngine();\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  /**\r\n   * Initialize the game state with default values\r\n   */\r\n  private initializeGameState(): GameState {\r\n    const maze = MAZE_LAYOUT.map(row => [...row]);\r\n    const pelletsRemaining = this.countPellets(maze);\r\n\r\n    return {\r\n      pacman: this.createPacMan(),\r\n      ghosts: this.createGhosts(),\r\n      maze,\r\n      score: 0,\r\n      highScore: parseInt(localStorage.getItem('pacman-highscore') || '0'),\r\n      lives: 3,\r\n      level: 1,\r\n      pelletsRemaining,\r\n      powerPelletActive: false,\r\n      powerPelletTimer: 0,\r\n      gameStatus: 'READY',\r\n      ghostEatenCount: 0,\r\n      fruitSpawned: false,\r\n      fruitPosition: null,\r\n      fruitScore: 0,\r\n      aiLearningLevel: 0,\r\n      showAIFeatures: true,\r\n      dangerMap: [],\r\n      playerPatterns: [],\r\n      screenShake: false,\r\n      vhsGlitch: false\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create Pac-Man with initial state\r\n   */\r\n  private createPacMan(): PacMan {\r\n    return {\r\n      position: { ...PACMAN_START_POSITION },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.NONE,\r\n      nextDirection: Direction.NONE,\r\n      animationFrame: 0,\r\n      isDead: false,\r\n      mouthOpen: true\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create all four ghosts with their unique properties\r\n   */\r\n  private createGhosts(): Ghost[] {\r\n    return Object.entries(GHOST_CONFIG).map(([type, config]) => ({\r\n      id: type as GhostType,\r\n      position: { ...config.startPosition },\r\n      velocity: { dx: 0, dy: 0 },\r\n      direction: Direction.UP,\r\n      state: type === 'BLINKY' ? GhostState.CHASE : GhostState.IN_HOUSE,\r\n      color: config.color,\r\n      targetPosition: { ...config.scatterTarget },\r\n      scatterTarget: { ...config.scatterTarget },\r\n      houseTimer: type === 'BLINKY' ? 0 : 60 + (Object.keys(GHOST_CONFIG).indexOf(type) * 30),\r\n      frightenedTimer: 0,\r\n      isFlashing: false,\r\n      lastDirection: Direction.UP,\r\n      pathPrediction: []\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Main game update loop - called at 60fps\r\n   */\r\n  update(currentTime: number, inputDirection: Direction): GameState {\r\n    // const deltaTime = currentTime - this.lastUpdateTime;\r\n    this.lastUpdateTime = currentTime;\r\n    this.frameCount++;\r\n\r\n    if (this.gameState.gameStatus !== 'PLAYING') {\r\n      return this.gameState;\r\n    }\r\n\r\n    // Update Pac-Man\r\n    this.updatePacMan(inputDirection);\r\n\r\n    // Update ghosts\r\n    this.updateGhosts();\r\n\r\n    // Check collisions\r\n    this.checkCollisions();\r\n\r\n    // Update power pellet timer\r\n    this.updatePowerPelletTimer();\r\n\r\n    // Update AI analysis\r\n    this.updateAIAnalysis();\r\n\r\n    // Check win/lose conditions\r\n    this.checkGameConditions();\r\n\r\n    // Update visual effects\r\n    this.updateVisualEffects();\r\n\r\n    // Spawn fruit occasionally\r\n    this.updateFruitSpawning();\r\n\r\n    return this.gameState;\r\n  }\r\n\r\n  /**\r\n   * Update Pac-Man position and animation\r\n   */\r\n  private updatePacMan(inputDirection: Direction): void {\r\n    const pacman = this.gameState.pacman;\r\n\r\n    // Handle direction changes\r\n    if (inputDirection !== Direction.NONE) {\r\n      pacman.nextDirection = inputDirection;\r\n      \r\n      // Record movement for AI learning\r\n      this.aiEngine.recordPlayerMovement(inputDirection);\r\n    }\r\n\r\n    // Try to change direction if possible\r\n    if (pacman.nextDirection !== pacman.direction) {\r\n      const nextPos = this.getNextPosition(pacman.position, pacman.nextDirection);\r\n      if (this.isValidMove(nextPos)) {\r\n        pacman.direction = pacman.nextDirection;\r\n        this.setVelocity(pacman, pacman.direction);\r\n      }\r\n    }\r\n\r\n    // Move Pac-Man\r\n    if (pacman.direction !== Direction.NONE) {\r\n      const nextPos = {\r\n        x: pacman.position.x + pacman.velocity.dx,\r\n        y: pacman.position.y + pacman.velocity.dy\r\n      };\r\n\r\n      // Handle tunnel wraparound\r\n      if (nextPos.x < 0) {\r\n        nextPos.x = GAME_CONFIG.MAZE_WIDTH - 1;\r\n      } else if (nextPos.x >= GAME_CONFIG.MAZE_WIDTH) {\r\n        nextPos.x = 0;\r\n      }\r\n\r\n      // Check if move is valid\r\n      if (this.isValidMove(nextPos)) {\r\n        pacman.position = nextPos;\r\n      } else {\r\n        // Stop if hitting wall\r\n        pacman.direction = Direction.NONE;\r\n        pacman.velocity = { dx: 0, dy: 0 };\r\n      }\r\n    }\r\n\r\n    // Update animation\r\n    if (this.frameCount % 8 === 0) {\r\n      pacman.mouthOpen = !pacman.mouthOpen;\r\n      pacman.animationFrame = (pacman.animationFrame + 1) % 4;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update all ghost positions and AI behavior\r\n   */\r\n  private updateGhosts(): void {\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      this.updateGhostState(ghost);\r\n      this.updateGhostMovement(ghost);\r\n      this.updateGhostAnimation(ghost);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update individual ghost state and target\r\n   */\r\n  private updateGhostState(ghost: Ghost): void {\r\n    // Handle house timer\r\n    if (ghost.state === GhostState.IN_HOUSE && ghost.houseTimer > 0) {\r\n      ghost.houseTimer--;\r\n      if (ghost.houseTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle frightened state\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      ghost.frightenedTimer--;\r\n      \r\n      // Start flashing when timer is low\r\n      if (ghost.frightenedTimer <= GAME_CONFIG.GHOST_FLASH_DURATION) {\r\n        ghost.isFlashing = Math.floor(ghost.frightenedTimer / 10) % 2 === 0;\r\n      }\r\n\r\n      if (ghost.frightenedTimer <= 0) {\r\n        ghost.state = GhostState.CHASE;\r\n        ghost.isFlashing = false;\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Handle eaten state\r\n    if (ghost.state === GhostState.EATEN) {\r\n      // Return to house\r\n      const housePos = GHOST_CONFIG[ghost.id].startPosition;\r\n      if (ghost.position.x === housePos.x && ghost.position.y === housePos.y) {\r\n        ghost.state = GhostState.CHASE;\r\n      }\r\n      ghost.targetPosition = housePos;\r\n      return;\r\n    }\r\n\r\n    // Normal chase/scatter behavior with AI adaptation\r\n    // const baseTarget = this.getGhostTarget(ghost);\r\n    ghost.targetPosition = this.aiEngine.adaptGhostBehavior(\r\n      ghost,\r\n      this.gameState.pacman,\r\n      this.gameState.ghosts\r\n    );\r\n\r\n    // Alternate between chase and scatter modes\r\n    const modeTime = Math.floor(this.frameCount / 600); // Change every 10 seconds\r\n    ghost.state = modeTime % 2 === 0 ? GhostState.CHASE : GhostState.SCATTER;\r\n  }\r\n\r\n  /**\r\n   * Update ghost movement using pathfinding\r\n   */\r\n  private updateGhostMovement(ghost: Ghost): void {\r\n    if (ghost.state === GhostState.IN_HOUSE) {\r\n      // Simple up-down movement in house\r\n      if (this.frameCount % 60 < 30) {\r\n        ghost.direction = Direction.UP;\r\n      } else {\r\n        ghost.direction = Direction.DOWN;\r\n      }\r\n      this.setGhostVelocity(ghost);\r\n      return;\r\n    }\r\n\r\n    // Get possible directions (can't reverse unless frightened)\r\n    const possibleDirections = this.getPossibleDirections(ghost.position)\r\n      .filter(dir => {\r\n        if (ghost.state === GhostState.FRIGHTENED) return true;\r\n        return this.getOppositeDirection(dir) !== ghost.lastDirection;\r\n      });\r\n\r\n    if (possibleDirections.length === 0) return;\r\n\r\n    // Choose direction based on target\r\n    let bestDirection = possibleDirections[0];\r\n    let shortestDistance = Infinity;\r\n\r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      // Random movement when frightened\r\n      bestDirection = possibleDirections[Math.floor(Math.random() * possibleDirections.length)];\r\n    } else {\r\n      // Move toward target\r\n      possibleDirections.forEach(direction => {\r\n        const nextPos = this.getNextPosition(ghost.position, direction);\r\n        const distance = this.manhattanDistance(nextPos, ghost.targetPosition);\r\n        \r\n        if (distance < shortestDistance) {\r\n          shortestDistance = distance;\r\n          bestDirection = direction;\r\n        }\r\n      });\r\n    }\r\n\r\n    ghost.lastDirection = ghost.direction;\r\n    ghost.direction = bestDirection;\r\n    this.setGhostVelocity(ghost);\r\n\r\n    // Move ghost\r\n    const nextPos = {\r\n      x: ghost.position.x + ghost.velocity.dx,\r\n      y: ghost.position.y + ghost.velocity.dy\r\n    };\r\n\r\n    // Handle tunnel wraparound\r\n    if (nextPos.x < 0) {\r\n      nextPos.x = GAME_CONFIG.MAZE_WIDTH - 1;\r\n    } else if (nextPos.x >= GAME_CONFIG.MAZE_WIDTH) {\r\n      nextPos.x = 0;\r\n    }\r\n\r\n    if (this.isValidMove(nextPos)) {\r\n      ghost.position = nextPos;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update ghost animation and visual effects\r\n   */\r\n  private updateGhostAnimation(ghost: Ghost): void {\r\n    // Update path prediction for AI visualization\r\n    if (this.frameCount % 30 === 0) { // Update every half second\r\n      const predictions = this.aiEngine.predictGhostMovements(\r\n        [ghost],\r\n        this.gameState.maze,\r\n        this.gameState.pacman\r\n      );\r\n      ghost.pathPrediction = predictions[ghost.id] || [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check collisions between Pac-Man and game elements\r\n   */\r\n  private checkCollisions(): void {\r\n    const pacmanPos = this.gameState.pacman.position;\r\n    const cellType = this.gameState.maze[pacmanPos.y][pacmanPos.x];\r\n\r\n    // Collect pellets\r\n    if (cellType === CellType.PELLET) {\r\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.playSound('CHOMP');\r\n    }\r\n\r\n    // Collect power pellets\r\n    if (cellType === CellType.POWER_PELLET) {\r\n      this.gameState.maze[pacmanPos.y][pacmanPos.x] = CellType.EMPTY;\r\n      this.gameState.score += GAME_CONFIG.POINTS_POWER_PELLET;\r\n      this.gameState.pelletsRemaining--;\r\n      this.activatePowerPellet();\r\n      this.playSound('POWER_PELLET');\r\n    }\r\n\r\n    // Collect fruit\r\n    if (this.gameState.fruitPosition && \r\n        pacmanPos.x === this.gameState.fruitPosition.x && \r\n        pacmanPos.y === this.gameState.fruitPosition.y) {\r\n      const fruitPoints = GAME_CONFIG.POINTS_FRUIT[Math.min(this.gameState.level - 1, 7)];\r\n      this.gameState.score += fruitPoints;\r\n      this.gameState.fruitScore = fruitPoints;\r\n      this.gameState.fruitPosition = null;\r\n      this.gameState.fruitSpawned = false;\r\n      this.playSound('FRUIT');\r\n    }\r\n\r\n    // Check ghost collisions\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      if (this.manhattanDistance(pacmanPos, ghost.position) < 1) {\r\n        if (ghost.state === GhostState.FRIGHTENED) {\r\n          // Eat ghost\r\n          ghost.state = GhostState.EATEN;\r\n          const points = GAME_CONFIG.POINTS_GHOST_BASE * Math.pow(2, this.gameState.ghostEatenCount);\r\n          this.gameState.score += points;\r\n          this.gameState.ghostEatenCount++;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('GHOST_EATEN');\r\n        } else if (ghost.state !== GhostState.EATEN) {\r\n          // Pac-Man dies\r\n          this.gameState.pacman.isDead = true;\r\n          this.gameState.lives--;\r\n          this.gameState.screenShake = true;\r\n          this.playSound('DEATH');\r\n          \r\n          if (this.gameState.lives <= 0) {\r\n            this.gameState.gameStatus = 'GAME_OVER';\r\n          } else {\r\n            // Reset positions\r\n            setTimeout(() => this.resetPositions(), 2000);\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Activate power pellet effect\r\n   */\r\n  private activatePowerPellet(): void {\r\n    this.gameState.powerPelletActive = true;\r\n    this.gameState.powerPelletTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n    this.gameState.ghostEatenCount = 0;\r\n\r\n    // Make ghosts frightened\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      if (ghost.state !== GhostState.EATEN && ghost.state !== GhostState.IN_HOUSE) {\r\n        ghost.state = GhostState.FRIGHTENED;\r\n        ghost.frightenedTimer = GAME_CONFIG.POWER_PELLET_DURATION;\r\n        ghost.isFlashing = false;\r\n        // Reverse direction\r\n        ghost.direction = this.getOppositeDirection(ghost.direction);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Update power pellet timer\r\n   */\r\n  private updatePowerPelletTimer(): void {\r\n    if (this.gameState.powerPelletActive) {\r\n      this.gameState.powerPelletTimer--;\r\n      if (this.gameState.powerPelletTimer <= 0) {\r\n        this.gameState.powerPelletActive = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update AI analysis and danger map\r\n   */\r\n  private updateAIAnalysis(): void {\r\n    if (this.frameCount % 10 === 0) { // Update every 6th of a second\r\n      // const analysis = this.aiEngine.analyzeGameState(\r\n      //   this.gameState.pacman,\r\n      //   this.gameState.ghosts,\r\n      //   this.gameState.maze\r\n      // );\r\n\r\n      this.gameState.dangerMap = this.aiEngine.generateDangerHeatmap(\r\n        this.gameState.ghosts,\r\n        this.gameState.maze\r\n      );\r\n\r\n      this.gameState.aiLearningLevel = this.aiEngine.getLearningLevel();\r\n      this.gameState.playerPatterns = this.aiEngine.getPlayerPatterns();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check win/lose conditions\r\n   */\r\n  private checkGameConditions(): void {\r\n    // Check if all pellets collected\r\n    if (this.gameState.pelletsRemaining <= 0) {\r\n      this.gameState.gameStatus = 'LEVEL_COMPLETE';\r\n      this.gameState.level++;\r\n      \r\n      // Reset maze and positions for next level\r\n      setTimeout(() => {\r\n        this.gameState.maze = MAZE_LAYOUT.map(row => [...row]);\r\n        this.gameState.pelletsRemaining = this.countPellets(this.gameState.maze);\r\n        this.resetPositions();\r\n        this.gameState.gameStatus = 'READY';\r\n      }, 2000);\r\n    }\r\n\r\n    // Update high score\r\n    if (this.gameState.score > this.gameState.highScore) {\r\n      this.gameState.highScore = this.gameState.score;\r\n      localStorage.setItem('pacman-highscore', this.gameState.score.toString());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update visual effects\r\n   */\r\n  private updateVisualEffects(): void {\r\n    // Reset screen shake\r\n    if (this.gameState.screenShake) {\r\n      setTimeout(() => {\r\n        this.gameState.screenShake = false;\r\n      }, 200);\r\n    }\r\n\r\n    // Random VHS glitch effect\r\n    if (Math.random() < 0.001) {\r\n      this.gameState.vhsGlitch = true;\r\n      setTimeout(() => {\r\n        this.gameState.vhsGlitch = false;\r\n      }, 100);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update fruit spawning logic\r\n   */\r\n  private updateFruitSpawning(): void {\r\n    if (!this.gameState.fruitSpawned && \r\n        this.gameState.pelletsRemaining < this.countPellets(MAZE_LAYOUT) * 0.7) {\r\n      // Spawn fruit when 70% of pellets are eaten\r\n      this.gameState.fruitSpawned = true;\r\n      this.gameState.fruitPosition = { x: 9, y: 15 }; // Center of maze\r\n      \r\n      // Remove fruit after 10 seconds\r\n      setTimeout(() => {\r\n        this.gameState.fruitPosition = null;\r\n        this.gameState.fruitSpawned = false;\r\n      }, 10000);\r\n    }\r\n  }\r\n\r\n  // Helper methods\r\n\r\n  private getGhostTarget(ghost: Ghost): Position {\r\n    const pacman = this.gameState.pacman;\r\n    \r\n    switch (ghost.id) {\r\n      case GhostType.BLINKY:\r\n        return pacman.position;\r\n        \r\n      case GhostType.PINKY:\r\n        return this.getPositionAhead(pacman.position, pacman.direction, 4);\r\n        \r\n      case GhostType.INKY:\r\n        const blinky = this.gameState.ghosts.find(g => g.id === GhostType.BLINKY);\r\n        if (blinky) {\r\n          const ahead = this.getPositionAhead(pacman.position, pacman.direction, 2);\r\n          return {\r\n            x: ahead.x + (ahead.x - blinky.position.x),\r\n            y: ahead.y + (ahead.y - blinky.position.y)\r\n          };\r\n        }\r\n        return pacman.position;\r\n        \r\n      case GhostType.CLYDE:\r\n        const distance = this.manhattanDistance(ghost.position, pacman.position);\r\n        return distance > 8 ? pacman.position : ghost.scatterTarget;\r\n        \r\n      default:\r\n        return pacman.position;\r\n    }\r\n  }\r\n\r\n  private getNextPosition(position: Position, direction: Direction): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: position.y - 1 };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: position.y + 1 };\r\n      case Direction.LEFT:\r\n        return { x: position.x - 1, y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: position.x + 1, y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getPositionAhead(position: Position, direction: Direction, distance: number): Position {\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        return { x: position.x, y: Math.max(0, position.y - distance) };\r\n      case Direction.DOWN:\r\n        return { x: position.x, y: Math.min(GAME_CONFIG.MAZE_HEIGHT - 1, position.y + distance) };\r\n      case Direction.LEFT:\r\n        return { x: Math.max(0, position.x - distance), y: position.y };\r\n      case Direction.RIGHT:\r\n        return { x: Math.min(GAME_CONFIG.MAZE_WIDTH - 1, position.x + distance), y: position.y };\r\n      default:\r\n        return position;\r\n    }\r\n  }\r\n\r\n  private getOppositeDirection(direction: Direction): Direction {\r\n    switch (direction) {\r\n      case Direction.UP: return Direction.DOWN;\r\n      case Direction.DOWN: return Direction.UP;\r\n      case Direction.LEFT: return Direction.RIGHT;\r\n      case Direction.RIGHT: return Direction.LEFT;\r\n      default: return Direction.NONE;\r\n    }\r\n  }\r\n\r\n  private getPossibleDirections(position: Position): Direction[] {\r\n    const directions: Direction[] = [];\r\n    \r\n    if (this.isValidMove(this.getNextPosition(position, Direction.UP))) {\r\n      directions.push(Direction.UP);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.DOWN))) {\r\n      directions.push(Direction.DOWN);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.LEFT))) {\r\n      directions.push(Direction.LEFT);\r\n    }\r\n    if (this.isValidMove(this.getNextPosition(position, Direction.RIGHT))) {\r\n      directions.push(Direction.RIGHT);\r\n    }\r\n\r\n    return directions;\r\n  }\r\n\r\n  private isValidMove(position: Position): boolean {\r\n    if (position.y < 0 || position.y >= GAME_CONFIG.MAZE_HEIGHT) return false;\r\n    if (position.x < 0 || position.x >= GAME_CONFIG.MAZE_WIDTH) return false;\r\n    \r\n    const cellType = this.gameState.maze[position.y][position.x];\r\n    return cellType !== CellType.WALL;\r\n  }\r\n\r\n  private setVelocity(entity: PacMan, direction: Direction): void {\r\n    const speed = GAME_CONFIG.PACMAN_SPEED;\r\n    switch (direction) {\r\n      case Direction.UP:\r\n        entity.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        entity.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        entity.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        entity.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        entity.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private setGhostVelocity(ghost: Ghost): void {\r\n    let speed = GAME_CONFIG.GHOST_SPEED;\r\n    \r\n    if (ghost.state === GhostState.FRIGHTENED) {\r\n      speed = GAME_CONFIG.FRIGHTENED_SPEED;\r\n    } else if (ghost.state === GhostState.EATEN) {\r\n      speed = GAME_CONFIG.GHOST_SPEED * 1.5; // Faster when returning to house\r\n    }\r\n\r\n    switch (ghost.direction) {\r\n      case Direction.UP:\r\n        ghost.velocity = { dx: 0, dy: -speed };\r\n        break;\r\n      case Direction.DOWN:\r\n        ghost.velocity = { dx: 0, dy: speed };\r\n        break;\r\n      case Direction.LEFT:\r\n        ghost.velocity = { dx: -speed, dy: 0 };\r\n        break;\r\n      case Direction.RIGHT:\r\n        ghost.velocity = { dx: speed, dy: 0 };\r\n        break;\r\n      default:\r\n        ghost.velocity = { dx: 0, dy: 0 };\r\n    }\r\n  }\r\n\r\n  private manhattanDistance(pos1: Position, pos2: Position): number {\r\n    return Math.abs(pos1.x - pos2.x) + Math.abs(pos1.y - pos2.y);\r\n  }\r\n\r\n  private countPellets(maze: CellType[][]): number {\r\n    let count = 0;\r\n    maze.forEach(row => {\r\n      row.forEach(cell => {\r\n        if (cell === CellType.PELLET || cell === CellType.POWER_PELLET) {\r\n          count++;\r\n        }\r\n      });\r\n    });\r\n    return count;\r\n  }\r\n\r\n  private resetPositions(): void {\r\n    this.gameState.pacman.position = { ...PACMAN_START_POSITION };\r\n    this.gameState.pacman.direction = Direction.NONE;\r\n    this.gameState.pacman.velocity = { dx: 0, dy: 0 };\r\n    this.gameState.pacman.isDead = false;\r\n\r\n    this.gameState.ghosts.forEach(ghost => {\r\n      ghost.position = { ...GHOST_CONFIG[ghost.id].startPosition };\r\n      ghost.direction = Direction.UP;\r\n      ghost.velocity = { dx: 0, dy: 0 };\r\n      ghost.state = ghost.id === GhostType.BLINKY ? GhostState.CHASE : GhostState.IN_HOUSE;\r\n      ghost.houseTimer = ghost.id === GhostType.BLINKY ? 0 : 60;\r\n    });\r\n\r\n    this.gameState.powerPelletActive = false;\r\n    this.gameState.powerPelletTimer = 0;\r\n    this.gameState.gameStatus = 'READY';\r\n  }\r\n\r\n  private playSound(soundName: string): void {\r\n    // Sound implementation would go here\r\n    // For now, just log the sound that would be played\r\n    console.log(`Playing sound: ${soundName}`);\r\n  }\r\n\r\n  // Public methods for external access\r\n\r\n  getGameState(): GameState {\r\n    return this.gameState;\r\n  }\r\n\r\n  startGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  pauseGame(): void {\r\n    this.gameState.gameStatus = 'PAUSED';\r\n  }\r\n\r\n  resumeGame(): void {\r\n    this.gameState.gameStatus = 'PLAYING';\r\n  }\r\n\r\n  restartGame(): void {\r\n    this.gameState = this.initializeGameState();\r\n  }\r\n\r\n  toggleAIFeatures(): void {\r\n    this.gameState.showAIFeatures = !this.gameState.showAIFeatures;\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}